## Введение

В настоящее время программные решения, выполненные и поставляемые как один или компекс плагинов, являются популярными, а их разработка, исследование особенностей построения и способа поставки - актуальные проблемы в области информационных технологий. Отчасти актуальность может быть объяснена тем обстоятельством, что разработка программного решения как комплекса плагинов является альтернативой микросервисной архитектуре. Однако в отличие от микросервисной, плагинная архитектура применима для разработки решений, предназначенных для автономной работы без необходимости сетевого взаимодействия между компонентами вычислительной системы.

Кроме того, в настоящее время существует возможность поставки одной и той же версии ПО в различных комплектациях. Комплектации отличаются друг от друга объемом реализованного в них функционала. Декомпозиция функционала по плагинам позволяет реалзовать вышеописанную возможность, что обеспечивает сокращение объема бесполезного для потребителя функционала и уменьшить стоимость поставки, что, как следствие, приводит к повышению конкурентоспособности программного продукта.

Оценить эффективность декомпозиции без объективной оценки невозможно. В работе [] приведена формула для ее рассета, описаны необходимые условия и ограничения ее применения. Однако отсутствует описание ее применения для реального проекта и не продемонстрировано, на сколько ее применение окажется эффективным.

Целью настоящей работы является провека пригодности теоретически описанных механизмов на реальном проекте. Задачами работы являются:

1. определение входных данных;
2. поиск оптимальной декомпозиции функционала по различным количествам плагинов;
3. формулировка вывода о целесообразности применения механизмов декомпозиции в реальных проектах.

## Исходные данные

Для достижения цели и выполнения обозначенных задач использовано программно-инструментальное средство конфигурирования с открытым исходным кодом "meta-configurator" (https://github.com/MetaConfigurator/meta-configurator.git) [*ссылка на работы по metaconfigurator*]. Для анализа использованы файлы исходного кода на ревизии 6068f048.

По результатам анализа сформировано:

1. список функциональных требований, которое реализует программно-инструментальное средство 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/requirements.csv);
2. список файлов исходного кода, которые реализуют выявленные функциональные требования 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/files.csv);
3. трассируемость функциональных требований на файлы исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/tracer.json);
4. зависимости между файлами исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/dependencies.json);
5. перечень комплектаций с указанием состава реализуемых в них требований 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/complectations.json).

## Методы

В рамках преобразования необходимо было определить исходные данные:

1. $l$ - число комплектаций
2. $m$ - число файлов исходного кода
3. $n$ - число функциональных требований
4. $Q_{n \times m}$ - матрица трассируемости функциональных требований на файлы исходного кода
5. $R_{l \times n}$ - матрица комплектаций
6. $D_{m \times m}$ - матрица зависимостей файлов исходного кода

Определяемые числа и матрицы необходимы для рассчета суммарной стоимости поставляемых комплектаций [] по следующему алгоритму:

1. $F_{l \times m} \gets R \cdot Q$
2. $\displaystyle \hat{F}_{l \times m} \gets F \cdot \sum^{m}_{i = 0}D^{i}$
3. $P_{l \times k} \gets f_{in}(\hat{F} \cdot X)$
4. $\dot{F}_{m \times l} \gets X \cdot P^{T}$
5. $\dot{R}_{n \times l} \gets f_{im}(Q \cdot \dot{F})$
6. $\dot{R}^{T} \cdot C \cdot \dot{R}$

В работе [] матрицы: 

1. $R$ обозначена как $E$;
2. $Q$ обозначена как $T$; 
3. $X$ обозначена как $A$.

В приведенном алгоритме величины $C$ и $k$ принимают следующие значения:

1. $C_{n \times n}, C \gets E_{n \times n}$
2. $k \in [1; 50], k \in \mathbb{Z}$

Преобразование результатов анализа кодовой базы в исходные данные работы алгоритма показло рамеры матриц, которыми предстоит аперировать при рассчете значения целевой функции:

1. $l = 10$
2. $m = 124$
3. $n = 161$

В работе [] приводится решение оптимизационной задачи путем ее сведения к задаче линейного программирования с последующим применением программных решателей. Для оценки количества переменных и ограничений в задаче линейного программирования были использованы следующие формулы:

1. Число переменных: $m \cdot k + l \cdot k + l \cdot m \cdot k + l \cdot n + l \cdot n \cdot (n + 1) / 2$
2. Число ограничений: $m + 2 \cdot l \cdot k + 3 \cdot l \cdot m \cdot k + 2 \cdot l \cdot n + 3 \cdot l \cdot n \cdot (n + 1) / 2$

Используя эти формулы можно оценить размеры задач линейного программирования при различных значениях k:

| $k$ | Число переменных | Число ограничений |
| :-: |         :-:      |        :-:        |
|  1  |       133394     |       398314      |
| 10  |       145760     |       431974      |
| 20  |       159500     |       469374      |
| 30  |       173240     |       506774      |
| 40  |       186980     |       544174      |
| 50  |       200720     |       581574      |

Из приведенного в работе [] переченя программных решателей использовать по открытым лицензиям для решения задач таких размеров можно только два: GNU Linear Programming Kit (glpk) и COIN-OR Branch-and-Cut (cbc). Кроме того, их применение сопряжено со значительными временными издержками. Для оценки потребного времени проводились его замеры со значениями коэффициента $k \in [1; 10]$ и уменьшенном значении $l = 1, R \gets R_{1}$.

Для проведения вычислений использовалось оборудование со следующими характеристиками:

1. операционная система - Ubuntu 23.04;
2. процессор - 2-ядерный процессор Intel Core i5 с тактовой частотой 1,8GHz;
3. объем ОЗУ - 8 ГБ.

Используемые версии решателей:

1. glpk версии 5.0;
2. cbc версии 2.10.12.

Результаты проведенных экспериментов приведены в таблице:

| $k$ | Число переменных | Число ограничений | glpk (cost) | cbc (cost) | glpk (duration) | cbc (duration) |
| :-: |   :-:   |   :-:   |  :-:  |  :-:  |  :-:  |    :-:  |
|  1  |  13451  |  39943  |  150  |  150  |  1.6  |    3.5  |
|  2  |  13700  |  40317  |  150  |  103  |  4.1  |    6.0  |
|  3  |  13949  |  40691  |  150  |  103  |  7.5  |   71.2  |
|  4  |  14198  |  41065  |  122  |  103  | 10.5  |   63.4  |
|  5  |  14447  |  41439  |  150  |  103  | 11.2  |  173.0  |
|  6  |  14696  |  41813  |  148  |  103  | 16.4  |  118.9  |
|  7  |  14945  |  42187  |  150  |  103  | 27.6  |   80.7  |
|  8  |  15194  |  42561  |  150  |  103  | 47.6  |   69.3  |
|  9  |  15443  |  42935  |  150  |  103  | 46.2  |   80.1  |
| 10  |  15692  |  43309  |  103  |  103  | 34.0  |   72.7  |

Сопоставляя размеры оптимизационных задач (таблица 1 и таблица 2), а так же оценки потребного времени был сделан вывод, что применение программных решателей потребует значительного времени для выполнения всех необходимых вычислительных экспериментов. В связи с этим было принято решение об использовании альтернативных способах решения оптимизационной задачи.

<!-- О генетических алгоритмах -->
Описываемые в работах [*про генетические алгоритмы*] решения оптимизационных задач достигаются за счет применения генетических алгоритмов. 

<!-- О методе отжига -->

<!-- Муравьиный алгоритм -->

<!-- RL -->

Исходя из вышеизложенного был сделан вывод, что в каестве альтернативы

<!-- Нужна подводка к нижеобозначенным таблицам -->

Применяемый генетический алгоритм имеет следующую конфигурацию:

| Параметр конфигурации     | Значение     |
|           :-:             |    :-:       |
|  Число поколений          |    1000      |
|  Число хромосом           |    4         |
|  Число генов              |    $m$       |
|  Тип кроссовера           | single-point |
|  Тип мутации              |    swap      |
|  Процент мутирующих генов |    10        |

Применяемый RL имеет следующую конфигурацию:

| Параметр конфигурации                    | Значение      |
|          :-:                             |       :-:     |
|  Число итераций                          |      1000     |
|  Пространство действий                   | MultiDiscrete |
|  Пространство наблюдения                 |      Box      |
|  Число измерений пространства наблюдения |      $k$      |
|  Алгоритм                                |      A2C      |

Значением функции адаптации является противоположное значение целевой функции. Это верно как при работе генетического алгоритма, так и при применении RL.

Для вычисления значения функции адаптации на каждой итерации должно производиться преобразование матрицы $X$ из генерируемого алгоритмом решения. Рассматривалось два варианта генерируемого решения:

1. $\dot{X}_{1 \times m \cdot k} = ||\dot{x}_{i}||$ - $m \cdot k$ бинарных значений;

2. $\ddot{X}_{1 \times m} = ||\ddot{x}_{i}||$ - $m$ целых значений в диапазоне $[1; k]$.

Преобразование $\dot{X}$ в $X$:

$$x_{i, j} = \dot{x}_{i \cdot (k - 1) + j} \quad i = \overline{1, m} \quad j = \overline{1, k}$$

Преобразование $\ddot{X}$ в $X$:

$$X = Z$$

$$j = \ddot{x}_{i} \quad x_{i, j} = 1 \quad i = \overline{1, m}$$

Анализ вариантов генерируемого решения показал, что преобразование $\ddot{X}$ в $X$ гарантирует выполнения условия $\displaystyle \sum_{i = 1}^{m}X_{i} = 1$ [], кроме того длина вектора $\ddot{X}$ меньше чем длина $\dot{X}$, что упрощает поиск оптимального решения. Поэтому принято решение генерировать на каждой итерации алгоритма вектор $\ddot{X}$.

| $k$ | genetic (cost) | rl (cost) | genetic (duration) | rl (duration) |
| :-: |     :-:        |     :-:   |        :-:         |     :-:       |
|  1  |     150        |     150   |        1.2         |     52.5      |
|  2  |     150        |     150   |        1.7         |     57.0      |
|  3  |     150        |     150   |        1.7         |     57.0      |
|  4  |     150        |     150   |        1.7         |     56.8      |
|  5  |     150        |     150   |        1.6         |     56.8      |
|  6  |     150        |     150   |        1.8         |     57.2      |
|  7  |     150        |     150   |        1.9         |     57.2      |
|  8  |     150        |     150   |        1.8         |     57.7      |
|  9  |     150        |     142   |        2.0         |     56.8      |
| 10  |     145        |     145   |        1.7         |     56.6      |

Оценка временных затрат показала, что с целью повышения результативности применения генетического алгоритма можно выполнять многократный его запуск с последующим анализом не одного, а многих результатов. Например, можно учитывать маинимальное, максимальное или среднее значение. Для RL это недопустимо, т.к. приведет к значительным временным издержакам проводимых вычислений. 

## Результаты и обсуждение

Для достижения цели настоящего исследования была проведена серия вычислительных экспериментов по решению оптимизационной задачи для различных значений коэффициента $k$. Вычислительные экперименты с применением генетического алгоритма для каждого из значений $k$ провоились по 100 раз с последующим определением максимального, минимального и среднего значений целевой функции. Для RL вычислительный эксперимент для каждого из значений $k$ выполнялся однократно.

На риснуке приводится графическая интерпритация выполненных вычислительных экспериментов.

![chart](chart.png)

Результаты экспериментов показывают, что для рассматриваемого проекта ПО применение разработанного в работе [] механизма актуально. Это подтверждает снижение суммарной стоимости поставляемых комплектаций ПО с ростом числа плагинов, по которым выполняется декомпозиция функционала.

## Заключение

<!-- В работе представлено использование генетического алгоритма и RL как альтернативы математической формализации с последующим применением программных решателей -->

<!-- Вывод: даже применение неточного эвритсического генетического алгоритма показывает существенную эволюцию системы, что демонстрирует пригодность полученных теоретических результатов работы [] на реальных проектах ПО с открытым исходным кодом. -->
