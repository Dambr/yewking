## Введение

В настоящее время программные решения, выполненные и поставляемые как один или компекс плагинов, являются популярными, а их разработка, исследование особенностей построения и способа поставки - актуальные проблемы в области информационных технологий. Отчасти актуальность может быть объяснена тем обстоятельством, что разработка программного решения как комплекса плагинов является альтернативой микросервисной архитектуре. Однако в отличие от микросервисной, плагинная архитектура применима для разработки решений, предназначенных для автономной работы без необходимости сетевого взаимодействия между компонентами вычислительной системы.

Кроме того, в настоящее время существует возможность поставки одной и той же версии ПО в различных комплектациях. Комплектации отличаются друг от друга объемом реализованного в них функционала. Декомпозиция функционала по плагинам позволяет реалзовать вышеописанную возможность, что обеспечивает сокращение объема бесполезного для потребителя функционала и уменьшить стоимость поставки, что, как следствие, приводит к повышению конкурентоспособности программного продукта.

Оценить эффективность декомпозиции без объективной оценки невозможно. В работе [] приведена формула для ее рассета, описаны необходимые условия и ограничения ее применения. Однако отсутствует описание ее применения для реального проекта и не продемонстрировано, на сколько ее применение окажется эффективным.

Целью настоящей работы является провека пригодности теоретически описанных механизмов на реальном проекте. Задачами работы являются:

1. определение входных данных;
2. поиск оптимальной декомпозиции функционала по различным количествам плагинов;
3. формулировка вывода о целесообразности применения механизмов декомпозиции в реальных проектах.

## Исходные данные

Для достижения цели и выполнения обозначенных задач использовано программно-инструментальное средство конфигурирования с открытым исходным кодом "meta-configurator" (https://github.com/MetaConfigurator/meta-configurator.git) [*ссылка на работы по metaconfigurator*]. Для анализа использованы файлы исходного кода на ревизии 6068f048.

По результатам анализа сформировано:

1. список функциональных требований, которое реализует программно-инструментальное средство 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/requirements.csv);
2. список файлов исходного кода, которые реализуют выявленные функциональные требования 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/files.csv);
3. трассируемость функциональных требований на файлы исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/tracer.json);
4. зависимости между файлами исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/dependencies.json);
5. перечень комплектаций с указанием состава реализуемых в них требований 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/complectations.json).

## Методы

В рамках преобразования необходимо было определить:

1. $l$ - число комплектаций
2. $m$ - число файлов исходного кода
3. $n$ - число функциональных требований
4. $Q_{n \times m}$ - матрица трассируемости функциональных требований на файлы исходного кода
5. $R_{l \times n}$ - матрица комплектаций
6. $D_{m \times m}$ - матрица зависимостей файлов исходного кода

Определяемые числа и матрицы необходимы для рассчета суммарной стоимости поставляемых комплектаций [] по следующему алгоритму:

1. $F_{l \times m} \gets R \cdot Q$
2. $\displaystyle \hat{F}_{l \times m} \gets F \cdot \sum^{m}_{i = 0}D^{i}$
3. $P_{l \times k} \gets f_{in}(\hat{F} \cdot X)$
4. $\dot{F}_{m \times l} \gets X \cdot P^{T}$
5. $\dot{R}_{n \times l} \gets f_{im}(Q \cdot \dot{F})$
6. $cost \gets \dot{R}^{T} \cdot C \cdot \dot{R}$

Здесь величины $C$ и $k$ принимают значения:

1. $C_{n \times n}$ - матрица дельт стоимости, в настоящей работе $C \gets E_{n \times n}$
2. $k$ - число плагинов, оно принимает значения в диапазоне $k \in [1; 50]$

Рассчет 
