## Введение

В настоящее время программные решения, выполненные и поставляемые как один или компекс плагинов, являются популярными, а их разработка, исследование особенностей построения и способа поставки - актуальные проблемы в области информационных технологий. Отчасти актуальность может быть объяснена тем обстоятельством, что разработка программного решения как комплекса плагинов является альтернативой микросервисной архитектуре. Однако в отличие от микросервисной, плагинная архитектура применима для разработки решений, предназначенных для автономной работы без необходимости сетевого взаимодействия между компонентами вычислительной системы.

Кроме того, в настоящее время существует возможность поставки одной и той же версии ПО в различных комплектациях. Комплектации отличаются друг от друга объемом реализованного в них функционала. Декомпозиция функционала по плагинам позволяет реалзовать вышеописанную возможность, что обеспечивает сокращение объема бесполезного для потребителя функционала и уменьшить стоимость поставки, что, как следствие, приводит к повышению конкурентоспособности программного продукта.

Оценить эффективность декомпозиции без объективной оценки невозможно. В работе [] приведена формула для ее рассета, описаны необходимые условия и ограничения ее применения. Однако отсутствует описание ее применения для реального проекта и не продемонстрировано, на сколько ее применение окажется эффективным.

Целью настоящей работы является провека пригодности теоретически описанных механизмов на реальном проекте. Задачами работы являются:

1. определение входных данных;
2. поиск оптимальной декомпозиции функционала по различным количествам плагинов;
3. формулировка вывода о целесообразности применения механизмов декомпозиции в реальных проектах.

## Исходные данные

Для достижения цели и выполнения обозначенных задач использовано программно-инструментальное средство конфигурирования с открытым исходным кодом "meta-configurator" (https://github.com/MetaConfigurator/meta-configurator.git) [*ссылка на работы по metaconfigurator*]. Для анализа использованы файлы исходного кода на ревизии 6068f048.

По результатам анализа сформировано:

1. список функциональных требований, которое реализует программно-инструментальное средство 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/requirements.csv);
2. список файлов исходного кода, которые реализуют выявленные функциональные требования 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/files.csv);
3. трассируемость функциональных требований на файлы исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/tracer.json);
4. зависимости между файлами исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/dependencies.json);
5. перечень комплектаций с указанием состава реализуемых в них требований 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/complectations.json).

## Методы

В рамках преобразования необходимо было определить исходные данные:

1. $l$ - число комплектаций
2. $m$ - число файлов исходного кода
3. $n$ - число функциональных требований
4. $Q_{n \times m}$ - матрица трассируемости функциональных требований на файлы исходного кода
5. $R_{l \times n}$ - матрица комплектаций
6. $D_{m \times m}$ - матрица зависимостей файлов исходного кода

Определяемые числа и матрицы необходимы для рассчета суммарной стоимости поставляемых комплектаций [] по следующему алгоритму:

1. $F_{l \times m} \gets R \cdot Q$
2. $\displaystyle \hat{F}_{l \times m} \gets F \cdot \sum^{m}_{i = 0}D^{i}$
3. $P_{l \times k} \gets f_{in}(\hat{F} \cdot X)$
4. $\dot{F}_{m \times l} \gets X \cdot P^{T}$
5. $\dot{R}_{n \times l} \gets f_{im}(Q \cdot \dot{F})$
6. $\dot{R}^{T} \cdot C \cdot \dot{R}$

Здесь величины $C$ и $k$ принимают значения:

1. $C_{n \times n}$ - матрица дельт стоимости, в настоящей работе $C \gets E_{n \times n}$
2. $k$ - число плагинов, оно принимает значения в диапазоне $k \in [1; 50]$

Преобразование результатов анализа кодовой базы в исходные данные работы алгоритма показло рамеры матриц, которыми предстоит аперировать при рассчете значения целевой функции:

1. $l = 10$
2. $m = 124$
3. $n = 161$

В работе [] приводится решение оптимизационной задачи путем ее сведения к задаче линейного программирования с последующим применением программных решателей. Для оценки количества переменных и ограничений в задаче линейного программирования были использованы следующие формулы:

1. Число переменных: $m \cdot k + l \cdot k + l \cdot m \cdot k + l \cdot n + l \cdot n \cdot (n + 1) / 2$
2. Число ограничений: $m + 2 \cdot l \cdot k + 3 \cdot l \cdot m \cdot k + 2 \cdot l \cdot n + 3 \cdot l \cdot n \cdot (n + 1) / 2$

Используя эти формулы можно оценить размеры задач линейного программирования при различных значениях k:

| $k$ | Число переменных | Число ограничений |
| :-: |         :-:      |        :-:        |
|  1  |       133394     |       398314      |
| 10  |       145760     |       431974      |
| 20  |       159500     |       469374      |
| 30  |       173240     |       506774      |
| 40  |       186980     |       544174      |
| 50  |       200720     |       581574      |

Из приведенного переченя программных решателей в работе [] использовать по открытым лицензиям для решения задач таких размеров можно только 2: glpk и cbc. Кроме того, их применение сопряжено со значительными временными издержками. Для оценки потребного времени проводились его замеры со значениями коэффициента $k \in [1; 10]$ и уменьшенном значении $l = 1, R \gets R_{1}$. Результаты проведенных экспериментов приведены в таблице:

| $k$ | Число переменных | Число ограничений | glpk (cost) | cbc (cost) | glpk (duration) | cbc (duration) |
| :-: |   :-:   |   :-:   |  :-:  |  :-:  |  :-:  |    :-:  |
|  1  |  13451  |  39943  |  150  |  150  |  1.6  |    3.5  |
|  2  |  13700  |  40317  |  150  |  103  |  4.1  |    6.0  |
|  3  |  13949  |  40691  |  150  |  103  |  7.5  |   71.2  |
|  4  |  14198  |  41065  |  122  |  103  | 10.5  |   63.4  |
|  5  |  14447  |  41439  |  150  |  103  | 11.2  |  173.0  |
|  6  |  14696  |  41813  |  148  |  103  | 16.4  |  118.9  |
|  7  |  14945  |  42187  |  150  |  103  | 27.6  |   80.7  |
|  8  |  15194  |  42561  |  150  |  103  | 47.6  |   69.3  |
|  9  |  15443  |  42935  |  150  |  103  | 46.2  |   80.1  |
| 10  |  15692  |  43309  |  103  |  103  | 34.0  |   72.7  |

Сопоставляя размеры оптимизационных задач (таблица 1 и таблица 2), а так же оценки потребного времени был сделан вывод, что применение программных решателей потребует значительного времени для выполнения всех необходимых вычислительных экспериментов.

<!-- О генетических алгоритмах -->
Было принято решение использовать альтернативные способы решения оптимизационной задачи. В работах [*про генетические алгоритмы*] рассматриваются генетические алгоритмы и их применение в различных конфигурациях. 

<!-- Почему используем генетику -->

<!-- Какую именно генетику (конфигурация) будем использовать -->

<!-- О методе отжига -->

<!-- Муравьиный алгоритм -->

<!-- RL -->

<!-- Здесь описываем, какую генетику и какой RL будем использовать -->

<!-- После этого таблица (график) сравнения быстродействия -->

Статистика быстродействия и результативности приведенных алгоритмов показывает, что для эффективной альтернативной. При этом для каждого значения коэффициента $k$ можно выполнять серию рассчетов с последующим их анализом.

## Результаты

Была проведена серия вычислительных экспериментов с целью сбора статистической информации о взаимосвязи коэффициента $k$ и значения целевой функции. Результаты экспериментов приведены в (*ссылка на github*).

Визуализация результатов вычислительных экспериментов приведена на рисунке:

<!-- График зависимости cost от k -->

## Обсуждение

<!-- Вывод: даже применение неточного эвритсического генетического алгоритма показывает существенную эволюцию системы, что демонстрирует пригодность полученных теоретических результатов работы [] на реальных проектах ПО с открытым исходным кодом. -->
