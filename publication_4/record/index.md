## Введение

В настоящее время программные решения, выполненные и поставляемые как один или компекс плагинов, являются популярными, а их разработка, исследование особенностей построения и способа поставки - актуальные проблемы в области информационных технологий. Отчасти актуальность может быть объяснена тем обстоятельством, что разработка программного решения как комплекса плагинов является альтернативой микросервисной архитектуре. Однако в отличие от микросервисной, плагинная архитектура применима для разработки решений, предназначенных для автономной работы без необходимости сетевого взаимодействия между компонентами вычислительной системы.

Кроме того, в настоящее время существует возможность поставки одной и той же версии ПО в различных комплектациях. Комплектации отличаются друг от друга объемом реализованного в них функционала. Декомпозиция функционала по плагинам позволяет реалзовать вышеописанную возможность, что обеспечивает сокращение объема бесполезного для потребителя функционала и уменьшить стоимость поставки, что, как следствие, приводит к повышению конкурентоспособности программного продукта.

Оценить эффективность декомпозиции без объективной оценки невозможно. В работе [] приведена формула для ее рассета, описаны необходимые условия и ограничения ее применения. Однако отсутствует описание ее применения для реального проекта и не продемонстрировано, на сколько ее применение окажется эффективным.

Целью настоящей работы является провека пригодности теоретически описанных механизмов на реальном проекте. Задачами работы являются:

1. определение входных данных;
2. поиск оптимальной декомпозиции функционала по различным количествам плагинов;
3. формулировка вывода о целесообразности применения механизмов декомпозиции в реальных проектах.

## Исходные данные

Для достижения цели и выполнения обозначенных задач использовано программно-инструментальное средство конфигурирования с открытым исходным кодом "meta-configurator" (https://github.com/MetaConfigurator/meta-configurator.git) [*ссылка на работы по metaconfigurator*]. Для анализа использованы файлы исходного кода на ревизии 6068f048.

По результатам анализа сформировано:

1. список функциональных требований, которое реализует программно-инструментальное средство 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/requirements.csv);
2. список файлов исходного кода, которые реализуют выявленные функциональные требования 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/files.csv);
3. трассируемость функциональных требований на файлы исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/tracer.json);
4. зависимости между файлами исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/dependencies.json);
5. перечень комплектаций с указанием состава реализуемых в них требований 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/complectations.json).

## Методы

Результаты анализа были преобразованы в исходные данные для работы формулы (). 
