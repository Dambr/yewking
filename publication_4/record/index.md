## Введение

В настоящее время программные решения, выполненные и поставляемые как один или компекс плагинов, являются популярными, а их разработка, исследование особенностей построения и способа поставки - актуальные проблемы в области информационных технологий. Отчасти актуальность может быть объяснена тем обстоятельством, что разработка программного решения как комплекса плагинов является альтернативой микросервисной архитектуре. Однако в отличие от микросервисной, плагинная архитектура применима для разработки решений, предназначенных для автономной работы без необходимости сетевого взаимодействия между компонентами вычислительной системы.

Кроме того, в настоящее время существует возможность поставки одной и той же версии ПО в различных комплектациях. Комплектации отличаются друг от друга объемом реализованного в них функционала. Декомпозиция функционала по плагинам позволяет реалзовать вышеописанную возможность, что обеспечивает сокращение объема бесполезного для потребителя функционала и уменьшить стоимость поставки, что, как следствие, приводит к повышению конкурентоспособности программного продукта.

Оценить эффективность декомпозиции без объективной оценки невозможно. В работе [] приведена формула для ее рассета, описаны необходимые условия и ограничения ее применения. Однако отсутствует описание ее применения для реального проекта и не продемонстрировано, на сколько ее применение окажется эффективным.

Целью настоящей работы является провека пригодности теоретически описанных механизмов на реальном проекте. Задачами работы являются:

1. определение входных данных;
2. поиск оптимальной декомпозиции функционала по различным количествам плагинов;
3. формулировка вывода о целесообразности применения механизмов декомпозиции в реальных проектах.

## Исходные данные

Для достижения цели и выполнения обозначенных задач использовано программно-инструментальное средство конфигурирования с открытым исходным кодом "meta-configurator" (https://github.com/MetaConfigurator/meta-configurator.git) [*ссылка на работы по metaconfigurator*]. Для анализа использованы файлы исходного кода на ревизии 6068f048.

По результатам анализа сформировано:

1. список функциональных требований, которое реализует программно-инструментальное средство 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/requirements.csv);
2. список файлов исходного кода, которые реализуют выявленные функциональные требования 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/files.csv);
3. трассируемость функциональных требований на файлы исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/tracer.json);
4. зависимости между файлами исходного кода 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/dependencies.json);
5. перечень комплектаций с указанием состава реализуемых в них требований 
(https://github.com/AlexeyShabliy/codebase-overview/blob/main/complectations.json).

## Методы

В рамках преобразования необходимо было определить исходные данные:

1. $l$ - число комплектаций
2. $m$ - число файлов исходного кода
3. $n$ - число функциональных требований
4. $Q_{n \times m}$ - матрица трассируемости функциональных требований на файлы исходного кода
5. $R_{l \times n}$ - матрица комплектаций
6. $D_{m \times m}$ - матрица зависимостей файлов исходного кода

Определяемые числа и матрицы необходимы для рассчета суммарной стоимости поставляемых комплектаций [] по следующему алгоритму:

1. $F_{l \times m} \gets R \cdot Q$
2. $\displaystyle \hat{F}_{l \times m} \gets F \cdot \sum^{m}_{i = 0}D^{i}$
3. $P_{l \times k} \gets f_{in}(\hat{F} \cdot X)$
4. $\dot{F}_{m \times l} \gets X \cdot P^{T}$
5. $\dot{R}_{n \times l} \gets f_{im}(Q \cdot \dot{F})$
6. $\dot{R}^{T} \cdot C \cdot \dot{R}$

Здесь величины $C$ и $k$ принимают значения:

1. $C_{n \times n}$ - матрица дельт стоимости, в настоящей работе $C \gets E_{n \times n}$
2. $k$ - число плагинов, оно принимает значения в диапазоне $k \in [1; 50]$

<!-- Теперь здесь описываем, как было выполнено преобразование, какие значения присвоены в константы и какие размеры имеют матрицы, а так же как выполнялось вычисление значений элементов матриц (округление мое любимое). Потом сказать, что давайте оценим размеры и ужаснемся. Проведем подъисследование и установим, что решателями мы эту задачу будем решать 100 лет -->

Преобразование результатов анализа кодовой базы в исходные данные работы алгоритма показло рамеры матриц, которыми предстоит аперировать при рассчете значения целевой функции:

1. $l = 10$
2. $m = 124$
3. $n = 161$

В работе [] приводится решение оптимизационной задачи путем ее сведения к задаче линейного программирования с последующим применением программных решателей. Для оценки количества переменных и ограничений в задаче линейного программирования были использованы следующие формулы:

<!-- variables: m * k + l * k + l * m * k + l * n + l * n * (n + 1) / 2 -->
<!-- constraints: m + 2 * l * k + 3 * l * m * k + 2 * l * n + 3 * l * n * (n + 1) / 2 -->

1. Число переменных: $m \cdot k + l \cdot k + l \cdot m \cdot k + l \cdot n + l \cdot n \cdot (n + 1) / 2$
2. Число ограничений: $m + 2 \cdot l \cdot k + 3 \cdot l \cdot m \cdot k + 2 \cdot l \cdot n + 3 \cdot l \cdot n \cdot (n + 1) / 2$

Используя эти формулы можно оценить размеры задач линейного программирования при различных значениях k:

<!-- Можно не просто табличку, можно целый график нарисовать -->

По полученным данным была сформулирована гипотеза, что применение программных решателей потребует значительных временных затрат. Поэтому появилась необходимость в альтернативном способе поиска оптимума. Искомый способ не обязательно должен для каждого значения $k$ обеспечивать теоретический минимум целевой функции, но на диапазоне $k \in [1; 50]$ выбранный алгоритм должен отображать тенденцию снижения суммарной стоимости поставок всех заявленных комплектаций.

<!-- Далее следует рассуждение, какой способ решения задачи лучше. Сюда же можно и про rl написать. -->

<!-- Предполагаемые кандидаты на методы (5 штучек бы):

1. Программные решатели
2. Генетический алгоритм
3. RL
4. Метод отжига (отметаем)
5. Метод муравьиной колонии (отметаем) -->

Решение оптимизационной задачи может быть выполнено с применением эвристических алгоритмов, такими как:

1. Генетический алгоритм
2. Метод отжига
3. Муравьиный алгоритм

В качестве альтернативы могут быть применены алгоритмы машинного обучения. В частонсти reinformed learning (RL) - обучение с подкреплением.

<!-- Здесь описываем, какую генетику и какой RL будем использовать -->

<!-- После этого таблица (график) сравнения быстродействия -->

Статистика быстродействия и результативности приведенных алгоритмов показывает, что для эффективной альтернативной. При этом для каждого значения коэффициента $k$ можно выполнять серию рассчетов с последующим их анализом.

## Результаты

Была проведена серия вычислительных экспериментов с целью сбора статистической информации о взаимосвязи коэффициента $k$ и значения целевой функции. Результаты экспериментов приведены в (*ссылка на github*).

Визуализация результатов вычислительных экспериментов приведена на рисунке:

<!-- График зависимости cost от k -->

## Обсуждение


