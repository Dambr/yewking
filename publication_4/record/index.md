## Аннотация

## Введение
В настоящее время в сфере информационных технологий актуальна задача поставки различных комплектаций программного обеспечения (ПО), полученных на основе одной и той же кодовой базы. Отчасти это может быть объяснено тем, что различные части кодовой базы могут потребовать включение различных библиотек, быть предназначенными различным потенциальным заказчикам и т.д.

Эффективным способом разделения функциональных частей является распределение их по различным компонентам в микросервисной архитектуре. Однако такой подход подразумевает взаимодействие компонентов приложения по сети, поддержку большого числа протоколов между ними и их асинхронную работу. Кроме того это увеличивает сложность отладки, т.к. на стадии компиляции невозможно проверить их версионную совместимость, совместимость протоколов взаимодействия и т.д.

Поставка решения в виде комплекса плагинов нивелирует обозначенные недостатки, т.к. взаимосвязи между компонентами известны на стадии компиляции, нет необходимости в дополнительных способах синхронизации и аналогично микросервисной архитектуре сохраняется возможность поставки решения с ограниченным объемом функционала.

Однако ограничение объема поставляемого функционала требует его декомпозиции на различные плагины и не может быть достинуто без его корректного осуществления. Кроме того, оптимальное в рамках одной отдельно взятой комплектации распределение функционала по плагинам может оказаться совершенно неприменимым при необходимости поставки в другой комплектации, которая так же как и первая находится в числе заявленных. Это обуславливает актуальность создания системы поддержки принятия решений (СППР), которая бы оценивала распределение и могла бы выполнять поиск оптимального.

В настоящей работе в качестве такой оценки использовано количество реализованных в комплектации требований: чем ближе эта величина к числу полезных в комплектации требований, тем меньше в комплектации реализовано бесполезных.

Целью настоящей работы является описание математической модели СППР и демонстрация ее работы при взаимодействию с кодовой базой реального проекта, заключающейся в разбиении его кодовой базы между плагинами в соответствии с заявленными комплектациями полезных функциональных требований.

Задачами работы являются:
1. описание сущностей предметной области и характера их взаимодействия;
2. составление математической модели;
3. анализ проекта с открытым исходным кодом и рассчет значений исходных данных для работы составленной математической модели;
4. проведение вычислительных экспериментов и оценка работоспособности модели.

## Описание модели

Сущностями предметной области являются:
1. функциональные требования - в них описывается функционал ПО;
2. файлы исходного кода - в них реализованы функциональные требования на языке программирования;
3. плагины - интеграционные единицы ПО в плагинную систему, включенный в поставку плагин.

Для сущностей характерно:
1. требование считается реализованным если в комплектацию включены все реализующие его файлы исходного кода;
2. чтобы файл был включен в комплектацию, в комплектацию должен быть включен плагин, содержащий его;
3. если в комплектацию включен плагин, то он включает в комплектацию все файл, которые содержит.

Сущности вступают в следующие взаимодействия:
1. файлы исходного кода реализуют функциональные требования, при чем один файл может задействован для реализации нескольких требований, а одно требование может быть реализовано в нескольких файлах;
2. файлы исходного кода имеют зависимости друг между другом и для осуществления поставки все зависимости должны быть разрешены;
3. файлы распределены по плагинам, при чем один плагин может включать несколько файлов, а один файл не может быть расположен одновременно в нескольких плагинах.

Таким образом образуется граф, в котором вершины проиндексированы и составляют:

1. $n$ функциональных требований;
2. $m$ файлов исходного кода;
3. $k$ плагинов.

Ребра в графе образуются при:

1. трассировании требований на файлы исходного кода - $n \times m$ связей;
2. наличии зависимостей между файлами - $m \times m$ связей;
3. распределении файлов между плагинами - $m \times k$ связей.

Приведенному описанию соответствует графовая математическая модель, приведенная на рисунке:

![alt text](graph.png "Граф")

Описанная графовая модель, используя информацию об обозначенных вершинах и ребрах, позволяет определять составы плагинов для поставки (алгоритм 1) и реализованных требований (алгоритм 2) в каждой из заявленных $l$ комплектаций.

Для алгоритма 1 исходными данными являются:

1. состав полезных в рамках комплектации требований;
2. трассируемость требований на файлы исходного кода;
3. зависимости между файлами исходного кода;
4. распределение файлов исходного кода по плагинам.

Алгоритм 1:
1. определение файлов исходного кода, релизующих полезные требования;
2. разрешение зависимостей между файлами;
3. определение состава плагинов, которые включают все задействованные файлы.

Пример выполнения алгоритма 1 приведен на рисунке:

![alt text](algorithm1.png "Алгоритм 1")

Для алгоритма 2 исходными данными являются:
1. состав плагинов в комплектации;
2. распределение файлов исходного кода по плагинам;
3. трассируемость требований на файлы исходного кода.

Алгоритм 2:
1. определение всех файлов, которые содержатся в плагинах;
2. определение требований, для реализации которых поставлены все необходимые файлы исходного кода.

Пример выполнения алгоритма 2 приведен на рисунке:

![alt text](algorithm2.png "Алгоритм 2")

Вывод: при заданном распределении файлов по плагинам и потребном одном требовании в рамках комплектации реализовано три требования.

Для построения аналитической формулы необходимо вершины и ребра графа описать при помощи математических объектов и ограничений, накладываемых на их значения.

Трассируемость требований на файлы исходного кода удобно описать в виде матрицы $Q_{n \times m} = ||q_{i, j}||$, элементы которой принимают значения в диапазоне $[0; 1]$. В ней номер строки соответствует индексу требования, а номер столбца - индексу файла. Элементы $Q$ принимают значения:
- $>0$ - если $j$-й файл задействован для реализации $i$-го требования;
- $0$ - если $j$-й файл не задействован для реализации $i$-го требования.

Считается, что все требования реализованы, поэтому вводится условие $\sum{Q_{i}} = 1$.

Зависимости между файлами исходного кода удобно описать в виде квадратной матрицы бинарных отношений $D_{m \times m} = ||d_{i, j}||$. В ней номера строк и стролбцов соответствуют индексам файлов. Элементы $D$ принимают значения:
- 1 - если $i$-й файл зависим от $j$-го;
- 0 - если $i$-й файл не зависим от $j$-го.

Считается, что файл не зависит от самого себя, поэтому $d_{i, i} = 0$.

Распределение файлов исходного кода между плагинами удобно описать в виде матрицы бинарных отношений $X_{m \times k} = ||x_{i, j}||$. В ней номер строки соответствует индексу файла, а номер столбца - индексу плагина. Элементы $X$ принимают значения:
- 1 - если $i$-файл относится к $j$-ому плагину;
- 0 - если $i$-файл не относится к $j$-ому плагину.

Считается, что все файлы распределены по плагинам, поэтому вводится условие $\sum{X_{i}} = 1$.

В рамках каждой из $l$ комплектаций полезные требования удобно описать в виде вектора бинарных отношений. Для $l$ комплектаций такие вектора образуют матрицу бинарных отношений $R_{l \times n} = ||r_{i, j}||$. В ней номер строки соответствует номеру комплектации, а номер столбца - индексу тербования. Элементы $R$ принимают значения:
- 1 - если в рамках $i$-й комплектации $j$-требование полезно;
- 0 - если в рамках $i$-й комплектации $j$-требование бесполезно.

Файлы, реализующие полезные требования в каждой из $l$ комплектаций, удобно описать в виде матрицы $F_{l \times n} = ||f_{i, j}||$. В ней номер строки соответствует номеру комплектации, а номер столбца - индексу файла. Значения элементов матрицы $F$:

$$F \gets R \cdot Q$$

Разрешение зависимостей файлов матрицы $F$:

$$F' \gets F \cdot D$$

Разрешение зависимостей файлов матрицы $F'$:

$$F'' \gets F' \cdot D = F \cdot D \cdot D = F \cdot D^{2}$$

Очевидно, что:

$$F^{(s)} \gets F \cdot D^{s}$$

Заметим, что глубина разрешения зависимостей не может превышать значение $m$, а значит общий состав файлов, который требуется включить в поставку:

$$\hat{F} \gets F + \sum_{i = 1}^{m}(F \cdot D^{i}) = F + F \cdot \sum_{i = 1}^{m}D^{i} = F \cdot E + F \cdot \sum_{i = 1}^{m}D^{i} = F \cdot (E + \sum_{i = 1}^{m}D^{i}) = F \cdot (D^{0} + \sum_{i = 1}^{m}D^{i}) = F \cdot \sum_{i = 0}^{m}D^{i}$$

Плагины, которые образуют поставку в каждой из $l$ комплектаций, удобно представить в виде матрицы $P_{l \times m} = ||p_{i, j}||$. В ней номер строки соответствует номеру комплектации, а номер столбца - индексу плагина. Значения элементов матрицы $P$:

$$P \gets f_{in}(F \cdot X)$$

$f_{in}$ - вспомогательная функция, которая применяется для пребразования значений элементов матрицы:

$$f_{in}(x) = \begin{cases}
    1 & \quad \text{если } x > 0 \\
    0 & \quad \text{если } x = 0
\end{cases}$$

Полученные значения матрицы $P$ следует интерпретировать так:

- в рамках $i$-й комплектации $j$-й плагин должен быть поставлен - если $p_{i, j } = 1$;
- в рамках $i$-й комплектации $j$-й плагин не должен быть поставлен - если $p_{i, j } = 0$.

Файлы, которые включены в каждую из $l$ комплектаций, удобно представить в виде матрицы $\dot{F}_{m \times l} = ||\dot{f}_{i, j}||$. В ней номер строки соответствует индексу файла, а номер столбца - номеру комплектации. Значения элементов матрицы $\dot{F}$:

$$\dot{F} \gets X \cdot {P^{T}}$$

Требования, которые реализованы в каждой из $l$ комплектаций, удобно представить в виде матрицы $\dot{R}_{n \times l} = ||\dot{r}_{i, j}||$. В ней номер строки соответствует индексу требования, а номер столбца - номеру комплектации. Значения элементов матрицы $\dot{R}$:

$$\dot{R} \gets f_{im}(Q \cdot \dot{F})$$

$f_{im}$ - вспомогательная функция, которая применяется для пребразования значений элементов матрицы:

$$f_{im}(x) = \begin{cases}
    1 & \quad \text{если } x \ge 1 \\
    0 & \quad \text{если } x < 1
\end{cases}$$

Полученные значения матрицы $\dot{R}$ следует интерпретировать так:

- в рамках $j$-й комплектации $i$-е требование реализовано - если $\dot{r}_{i, j} = 1$;
- в рамках $j$-й комплектации $i$-е требование не реализовано - если $\dot{r}_{i, j} = 0$.

Таким образом может быть составлена и решена оптимизационная задача с целевой функцией минимизации:

$$\min_{X} \sum \sum \Bigg[ f_{im} \Bigg( Q \cdot \bigg( X \cdot \Big[ f_{in} \big( (R \cdot Q \cdot \sum_{i = 0}^{m}D^{i}) \cdot X  \big)  \Big]^{T}  \bigg) \Bigg)  \Bigg]^{T} $$

## Исходные данные для решения оптимизационной задачи

В качестве исходных данных предполгалось задействовать ПО с открытым исходным кодом, которое было бы по своим функциональным возможностям полезным не одной категории пользователей, а так же обеспечивало комплекс функциональных возможностей для целенаправленного разделения его на разные комплектации.

Для проведения экспериментов было выбрано веб-приложение с открытым исходным кодом "meta-configurator". Оно генерирует графический пользовательский интерфейс в зависимости от схемы, документ в соответствии с которой загрузил пользователь. Благодаря этому достигается значительное сокращение затрат на разработку и поддержку специфичного интерфейса для конкретного формата.

Оно использует подход "схема - пользовательский интерфейс" с тремя ключевыми особенностями:

1. обеспечивает унифицированное представление, сочетающее достоинства как графического интерфейса, так и текстового редактора;
2. обеспечивает наличие редактора схем;
3. поддерживает расширенные функции схем, включая условия и ограничения.

Результаты проведенного разработчиками исследования среди пользователей свидетельствуют об эффективности предложенного ими подхода извлечения информации из данных и схем, а так же их редактирования.

В контексте настоящей работы работа с пользователями, а так же широкий спектр функциональных возможностей ПО обуславливает актуальность применения теоретических результатов исследования на этом практическом примере. Так, например, можно было бы разделять и поставлять независимо работу со схемами в форматах JSON и XML или управление данными и управление схемами.

Был проведен анализ кодовой базы ПО (https://github.com/MetaConfigurator/meta-configurator.git на ревизии 6068f048) с целью выявления:

1. функциональных требований
2. файлов исхоного кода
3. трассируемости требований на файлы исходного кода
4. зависимостей между файлами исходного кода

Так же по результатам анализа должны были быть сформированы предполагаемые составы комплектаций.

В ходе анализаци было проанализировано:
|  Язык (формат)  | Количество файлов | Количество строк |
|       :-:       |       :-:         |        :-:       |
| TypeScript      |       143         |       19095      |
| JSON            |        12         |       12397      |
| Vuejs Component |        56         |        6656      |
| Text            |        13         |         195      |
| JavaScript      |         4         |          66      |
| Markdown        |         2         |          68      |
| YAML            |         2         |          28      |
| Dockerfile      |         1         |          22      |
| HTML            |         1         |          15      |
| CSS             |         1         |           5      |
| Итого           |       241         |       38547      |

Не все проанализированные файлы содержат исходный код. Кроме того, не все файлы исходного кода заействованы в реализации каких-либо функциональных требований. Анализ показал, что часть файлов содержат отладочные процедуры, являются конфигурационными или в них описаны сценарии сборки проекта. По результатам анализа сформировано:

1. список функциональных требований, которое реализует программно-инструментальное средство - https://github.com/AlexeyShabliy/codebase-overview/blob/main/requirements.csv;
2. список файлов исходного кода, которые реализуют выявленные функциональные требования - https://github.com/AlexeyShabliy/codebase-overview/blob/main/files.csv;
3. трассируемость функциональных требований на файлы исходного кода - https://github.com/AlexeyShabliy/codebase-overview/blob/main/tracer.json;
4. зависимости между файлами исходного кода - https://github.com/AlexeyShabliy/codebase-overview/blob/main/dependencies.json;
5. перечень комплектаций с указанием состава реализуемых в них требований -  https://github.com/AlexeyShabliy/codebase-overview/blob/main/complectations.json.

Результаты анализа сконвертированы в матрицы $R_{l \times n}, Q_{n \times m}, D_{m \times m}$, имеющие следующие размеры:

1. $l = 10$
2. $m = 124$
3. $n = 161$

## Вычислительные эксперименты
Вычислительные эксперименты проводились с целью подтвердить или опровергнуть гипотезу, что с увеличением числа плагинов количество бесполезного функционала по отношению ко всем возможным комплектациям будет уменьшаться.
Для проведения вычислений использовалось оборудование со следующими характеристиками:

1. операционная система - Ubuntu 23.04;
2. процессор - 2-ядерный процессор Intel Core i5 с тактовой частотой 1,8GHz;
3. объем ОЗУ - 8 ГБ.

Вычислительные эксперименты заключались в поиске оптимальных значений матрицы $X$, которые бы максимизировали значение обратное целевой функции.
Рассматривалось два режима работы алгоритма поиска значений матрицы $X$:

1. $\dot{X}_{1 \times m \cdot k} = ||\dot{x}_{i}||$ - $m \cdot k$ бинарных значений;

2. $\ddot{X}_{1 \times m} = ||\ddot{x}_{i}||$ - $m$ целых значений в диапазоне $[1; k]$.

Преобразование $\dot{X}$ в $X$:

$$x_{i, j} = \dot{x}_{i \cdot (k - 1) + j} \quad i = \overline{1, m} \quad j = \overline{1, k}$$

Преобразование $\ddot{X}$ в $X$:

$$X = Z$$

$$j = \ddot{x}_{i} \quad x_{i, j} = 1 \quad i = \overline{1, m}$$

Анализ вариантов генерируемого алгоритмом решения показал, что преобразование $\ddot{X}$ в $X$ гарантирует выполнения условия $\displaystyle \sum_{i = 1}^{m}X_{i} = 1$, кроме того длина вектора $\ddot{X}$ меньше чем длина $\dot{X}$, что упрощает поиск оптимального решения. Поэтому было решено генерировать на каждой итерации алгоритма вектор $\ddot{X}$.

Поиск оптимальных значений матрицы $X$ методом полного перебора на задаче размерности представленных исходных не представляется возможным. В связи с этим использовались альтернативные способы решения оптимизационной задачи. Выбран один эвристический алгоритм и один метод машинного обучения. В качестве эвристического алгоритма был выбран генетический алгоритм, в качестве метода машинного обучения - reinforcement learning (RL, обучение с подкреплением).

Применяемый генетический алгоритм имеет следующую конфигурацию:

| Параметр конфигурации     | Значение     |
|           :-:             |    :-:       |
|  Число поколений          |    1000      |
|  Число хромосом           |    4         |
|  Число генов              |    $m$       |
|  Тип кроссовера           | single-point |
|  Тип мутации              |    swap      |
|  Процент мутирующих генов |    10        |

Применяемый RL имеет следующую конфигурацию:

| Параметр конфигурации                    | Значение      |
|          :-:                             |       :-:     |
|  Число итераций                          |      1000     |
|  Пространство действий                   | MultiDiscrete |
|  Пространство наблюдения                 |      Box      |
|  Число измерений пространства наблюдения |      $k$      |
|  Алгоритм                                |      A2C      |

Было выполнено сравнение их быстродействия на задаче меньшей размерности, в которой $l = 1, R = R_{1}$. Результаты сравнения быстродействия приведены в таблице:

| $k$ | genetic (cost) | rl (cost) | genetic (duration) | rl (duration) |
| :-: |     :-:        |     :-:   |        :-:         |     :-:       |
|  1  |     150        |     150   |        1.2         |     52.5      |
|  2  |     150        |     150   |        1.7         |     57.0      |
|  3  |     150        |     150   |        1.7         |     57.0      |
|  4  |     150        |     150   |        1.7         |     56.8      |
|  5  |     150        |     150   |        1.6         |     56.8      |
|  6  |     150        |     150   |        1.8         |     57.2      |
|  7  |     150        |     150   |        1.9         |     57.2      |
|  8  |     150        |     150   |        1.8         |     57.7      |
|  9  |     150        |     142   |        2.0         |     56.8      |
| 10  |     145        |     145   |        1.7         |     56.6      |

Оценка быстродействия показала, что с целью повышения результативности применения генетического алгоритма можно выполнять многократный его запуск с последующим анализом не одного, а многих результатов. Например, можно учитывать минимальное, максимальное и среднее значения. Для RL это недопустимо, т.к. требует значительных временных затрат на проведение вычислений.

Была проведена серия вычислительных экспериментов по решению оптимизационной задачи для различных значений коэффициента $k$ в диапазоне $[1; 50]$. Вычислительные экперименты с применением генетического алгоритма для каждого из значений $k$ провоились по 100 раз с последующим определением максимального, минимального и среднего значений целевой функции. Для RL вычислительный эксперимент для каждого из значений $k$ выполнялся однократно.

На риснуке приводится графическая интерпритация выполненных вычислительных экспериментов.

![chart](chart.png)

Результаты экспериментов показывают, что для рассматриваемого проекта ПО применение разработанного в настоящей работе механизма СППР актуально. Это подтверждает снижение суммарной стоимости поставляемых комплектаций ПО с ростом числа плагинов, по которым выполняется декомпозиция функционала.

## Заключение
С статье предложена математическая модель для СППР. Она опробована на реальном проекте с открытым исходным кодом разными оптимизационными алгоритмами, в том числе с задействованием технологии искусственного интеллекта.
В дальнейших исследованиях предполагается доработать целевую функцию так, чтобы она учитывала не признак реализованности требования, а величину издержек на разработку или сопровождение. Кроме того предполагается выполнение математической формализации оптимизационной задачи с целью применения для ее решения программных решателей, таких как GNU Linear Programming Kit и COIN-OR Branch-and-Cut, а так же последующее сравнение с предсталенными в настоящей работе способами решения оптимизационной задачи.
