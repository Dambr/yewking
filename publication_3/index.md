# Оптимизация состава комплектаций программного обеспечения

## Аннотация

В настоящей статье рассматривается решение оптимизационной задачи поиска оптимального распределения функционала с целью уменьшения стоимости заявленных комплектаций программного обеспечения (ПО). Для достижения цели рассматриваемая предметная область описана в виде графа. Описано два решения задачи на графе: математическая формализация задачи с последующей формулировкой задачи линейного программирования и применение генетического алгоритма. Сформулирована и подтверждена экспериментально гипотеза относительно условий применения того или иного метода решения.

## Введение

В настоящее время решение оптимизационных задач - востребованное направление в сфере информационных технологий, например для программного обеспечения. Решение таких задач актуально не только для оптимизации технической составляющей программных решений, но и экономической их составляющей. Для технической составляющей актуальными являются вопросы оптимизации работы с разделяемыми рисурсами, организация распределенных вычислений и т.д. Для экономической составляющей важны такие аспекты как оптимизация временных издержек на разработку, сопровождение и послепродажное обслуживание.

Отдельно в экономическом аспекте выделяется стоимость поставляемого решения. Она определяет на каком объеме или сегменте рынка программное решение будет востребовано, а во-вторых влияет на конкурентоспособность решения на этом объеме рынка.

Для оцениванивания стоимости существуют различные подходы и на ее конеченую величину влияют многие факторы. В настоящей работе в качестве определяющего фактора выделены функциональные требования: их состав и стоимость каждого из них.

Реализация функционального требования обусловлена рядом стоимостных издержек и характеризуется стоимостной величиной, оценка которой индивидуальна, зависит от проекта и устанавливается производителем.

Имея сведения об объеме стоимостных издержек каждого из реализованных требований можно оценить суммарную их величину применимо для всей версии ПО вцелом.

Однако существует возможность поставки одной и той же версии ПО в различных комплектациях. При этом величины стоимостных издержек реализованного требования зависят от реализованных смежных требований и в разных комплектациях могут отличаться друг от друга.

Пример систем, для которых это актуально - плагинные системы. В них интеграционной единицей, несущей конечный объем функционала, является плагин. Так, комплектациями являются различные составы плагинов.

В таких системах выделяют следующие сущности предметной области:

1. функциональные требования;
2. файлы исходного кода; 
3. плагины.

Сущности образуют друг с другом следующие связи:

1. в файлах исходного кода на языке программирования описана реализация функциональных требований;
2. файлы исходного имеют зависимости друг на друга и для осуществляения поставки все зависимости должны быть разрешены;
3. плагины содержат файлы исходного кода и обеспечивают интеграцию с плагинной средой выполнения.

Сущности и связи между ними образуют граф. Используя его можно определить комплектации плагинов. Каждая комплектация реализует конечный и одназно определяемый состав требований.

Оптимизация состава комплектаций заключается в решении задачи оптимальной декомпозиции файлов исходного кода между плагинами. Критерием оптимальности является суммарная стоимость издержек всех сформированных комплектаций.

## Описание модели

### Граф

На рисунке приведен пример графа, построенного по описанию сущностей предметной области.

![alt text](images/graph.png "Граф")

Вершины в графе образуют:

1. $n$ функциональных требований;
2. $m$ файлов исходного кода;
3. $k$ плагинов.

$$n, m, k > 0 \quad n, m, k \in \mathbb{Z}$$

Ребра в графе образуются от:

1. трассируемости требований на файлы исходного кода;
2. наличия функциональных зависимостей между файлами исходного кода;
3. распределения файлов по плагинам.

### Полезные требования
Полезных требований может быть $l$ комбинаций. Каждой из таких комбинаций должна соответствовать комплектация, которая обеспечивает выполнение полезных требований. Соответственно должно быть $l$ комплектаций.

Полезные требования образуют матрицу $R_{l \times n} = ||r_{i, j}||$. В ней номер строки соответствует номеру комплектации. Номер столбца соответствует индексу требования. Если в рамках $\tilde{l}$-й комплектации $\tilde{n}$-е требование полезно $r_{i, j} = 1$. Иначе $r_{i, j} = 0$.

$$r_{i, j} \in \{0, 1\} \quad \sum R_{i} \ge 1 \quad i = \overline{1, l} \quad j= \overline{1, n}$$

### Трассируемость требований на файлы исходного кода

Трассируемость требований на файлы исходного кода описывает связь требований и файлов. Связь характеризуется степенью ответственности файла для реализации требования.

Эти связи можно представить в виде матрицы $Q_{n \times m} = ||q_{i, j}||$. В ней номер строки - это индекс требования. Номер столбца - индекс файла исходного кода. Элементы $Q$ описывают долю ответственности файла для реализации требования. 

Каждый файл может быть необходим для реализации одного или нескольких требований, а каждое требование реализовано в одном или нескольких файлах. Допускается, что могут быть файлы, которые не задействованы в реализации хотябы одного требования, но каждое требование должно быть реализовано. За признак реализованности положена сумма соответствующих элементов матрицы, она должна быть равна $1$. Вследствие этого, элементы матрицы $Q$ удовлетворяют следующим условиям:

$$0 \le q_{i, j} \le 1 \quad \sum Q_{i} = 1 \quad i = \overline{1, n} \quad j = \overline{1, m}$$

### Полезные файлы исходного кода

Матрица $F_{l \times m} = ||f_{i, j}||$ описывает полезные к поставке файлы исходного кода в каждой из комплектаций. Номер строки соответствует номеру комплектации. Номер столбца соответствует индексу файла. Если в рамках $i$-й комплектации $j$-й файл полезен $f_{i, j} > 0$. Иначе $f_{i, j} = 0$.

Заметим, что если файл полезен, то нет обязательного условия на равенство значения элемента матрицы. Достаточно чтобы его значение было положительным числом.

$$f_{i, j} \ge 0 \quad i = \overline{1, l} \quad j = \overline{1, m}$$

Матрицы $F$ и $R$ связаны друг с другом через $Q$:

$$F \gets R \cdot Q$$

### Зависимости между файлами исходного кода

Файлы исходного кода имеют зависимости между друг другом. Зависимость одного файла от другого образует направленную связь, т.е. если первый файл зависит от второго, то второй необязательно зависит от первого.

Такие связи можно представить в виде квадратной матрицы бинарных отношений $D_{m \times m} = ||d_{i, j}||$. В ней номера строк и столбцов соответствуют индексам файлов исходного кода. Если $i$-й фал имеет зависимость на $j$-й, то $d_{i, j} = 1$. Иначе $d_{i, j} = 0$. Полагается, что файл не зависит сам от себя, поэтому значения элементов на главной диагонале равны $0$.

$$d_{i, j} \in \{0, 1\} \quad d_{i, i} = 0 \quad i = \overline{1, m} \quad j = \overline{1, m}$$

### Разрешение зависимостей между файлами исходного кода

Для возможности включения в поставку файла исходного кода необходимо разрешить его зависимости. Разрешение зависимостей подразумевает включение в поставку тех файлов, от которых зависит изначальный. Для дополнительно включаемых файлов так же должны быть разрешены их зависимости.

Зависимости полезных файлов:

$$F' \gets F \cdot D$$

Их зависимости:

$$F'' \gets F' \cdot D = F \cdot D \cdot D = F \cdot D^{2}$$

Очевидно, что:

$$F^{(\sigma)} \gets F \cdot D^{\sigma}$$

Заметим, что максимальная глубина зависимостей не может превышать значение $m$, поэтому досточно разрешить зависимости до этого значения глубины.

Матрица $\hat{F}_{l \times m} = ||\hat{f}_{i, j}||$ описывает полезные файлы с учетом разрешения их зависимостей. Аналогично матрице $F$ в ней номер строки соответствует номеру комплектации, а номер столбца - индексу файла. Для вычисления значений матрицы необходимо просуммировать матрицу полезных файлов и каждую из матриц разрешения зависимостей.

$$\hat{F} \gets F + F' + F'' + ... + F^{(m)} = F + F \cdot D + F \cdot D^{2} + ... + F \cdot D^{m} = F \cdot (E + \sum^{m}_{i = 1}D^{i}) = F \cdot (D^{0} + \sum^{m}_{i = 1}D^{i}) = F \cdot \sum^{m}_{i = 0}D^{i}$$

Для значений матрицы $\hat{F}$ так же как и для значений матрицы $F$ характерно, что отсутствует ограничение на положительное значение.

$$\hat{f}_{i, j} \ge 0 \quad i = \overline{1, l} \quad j = \overline{1, m}$$

В результате вычислений элементы матрицы $\hat{F}$ могут принимать на столько большие значения, что дальнейшее с ними взаимодействие может быть затруднено. С целью нивелирования данного обстоятельства можно изменить значения матрицы $\hat{F}$ преобразовав их к бинарным отношениям применив следующую функцию:

$$f_{in}(x) = \begin{cases}
    0 & \quad \text{если } x = 0 \\
    1 & \quad \text{если } x > 0
\end{cases}$$

### Распределение файлов по плагинам
Файлы исходного кода распределены по плагинам. Для включения в поставку файла необходимо включить в комплектацию плагин, который этот файл содержит. Включенный в комплектацию плагин добавляет в поставку все файлы, которые содержит.

Распределение файлов по плагинам образуют матрицу бинарных отношений $X_{m \times k} = ||x_{i, j}||$. В ней номер строки соответствует индексу файла, номер столбца - индексу плагина. Если $i$-й файл относится к $j$-му плагину, то $x_{i, j} = 1$. Иначе $x_{i, j} = 0$.

Плагин может включать несколько файлов, а один файл не может относиться одновременно к разным плагинам. Каждый файл должен относиться к какому-либо плагину. Не каждый плагин должен включать хотя бы один файл. Именно поиск распределения файлов по плагинам предполагается в оптимизационной задаче. Вследствие этого элементы матрицы $X$ удовлетворяют следующим условиям:

$$x_{i, j} \in \{0, 1\} \quad \sum X_{i} = 1 \quad i = \overline{1, m} \quad j = \overline{1, k}$$

### Комплектации плагинов

Комплектация плагинов обеспечивает поставку полезного функционала и минимизирует поставку бесполезного. Каждая комплектация включает от $1$ до $k$ плагинов.

Комплектации плагинов для каждой комбинации полезных требований образуют матрицу бинарных отношений $P_{l \times k} = ||p_{i, j}||$. Номер строки соответсвует номеру комплектации. Номер столбца соответствует индексу плагина. Если $j$-й плагин должен быть включен в $i$-ю комплектацию $p_{i, j} = 1$. Иначе $p_{i, j} = 0$.

$$p_{i, j} \in \{0, 1\} \quad \sum P_{i} \ge 1 \quad i = \overline{1, l} \quad j = \overline{1, k}$$

Матрицы $P$ и $\hat{F}$ связаны друг с другом через $X$:

$$P \gets f_{in}(\hat{F} \cdot X)$$

### Алгоритм определения состава комплектаций

Алгоритм определения состава комплектаций:

1. ЛПР формирует комбинации полезных требоний $R_{l \times n}$.
2. Для каждой из них определяются полезные файлы исходного кода:

$$F_{l \times m} \gets R \cdot Q$$

3. Составляется матрица учитывающая полезные файлы и их разрешенные зависимости:

$$\hat{F}_{l \times m} \gets F \cdot \sum^{m}_{i = 0}D^{i}$$

4. Определяется состав плагинов каждой из комплектаций:

$$P_{l \times k} \gets f_{in}(\hat{F} \cdot X)$$

### Поставляемый код

Поставляемый код - это весь код, который относится к поставляемым в рамках комплектации плагинам. Его описывает матрица бинарных отношений $\dot{F}_{m \times l} = ||\dot{f}_{i, j}||$. В ней номер строки соответствует индексу файла. Номер строки соответствует номеру комплектации.

$$\dot{f}_{i, j} \in \{0, 1\} \quad i = \overline {1, m} \quad j = \overline{1, l}$$

Матрицы $\dot{F}$ и $P$ связаны друг с другом через $X$:

$$\dot{F} \gets X \cdot P^{T}$$

Примечательно, что ограничения значений матриц $X$ и $P$ обеспечивают бинарность отношений $\dot{F}$. Благодаря этому отсутсвует необходимость дополнительной бработки ее значений, например, с использованием функции $f_{in}$.

### Реализованные требования

Реализованным называется такое требование, для которого поставлен весь код, который задействован в его реализации. Состав реализованных требований влияет на стоимость комплектации.

Для определения того, поставляется ли весь код, ответственный за реализацию требования, применяется функция:

$$f_{im}(x) = \begin{cases}
    0 & \quad \text{если } x < 1 \\
    1 & \quad \text{если } x \ge 1
\end{cases}$$

Матрица бинарных отношений $\dot{R}_{l \times n} = ||\dot{r}_{i, j}||$ описывает состав реализованных требований в каждой из комплектаций. Номер строки соответствует номеру комплектации. Номер столбца соответствует индексу требования.

$$\dot{r}_{i, j} \in \{0, 1\} \quad i = \overline{1, l} \quad j = \overline{1, n}$$

Матрицы $\dot{R}$ и $\dot{F}$ связаны друг с другом через $Q$:

$$\dot{R} \gets f_{im}\big((Q \cdot \dot{F})^{T}\big)$$

### Стоимостные характеристики

Стоимость реализованного требования не является постоянной величиной и может быть изменена в зависимости от реализации в комплектации смежных требований.

Величины изменения стоимости реализации требований описывает матрица $C_{n \times n} = ||c_{i, j}||$. В ней номера строк и столбцов соответствуют индексам требований. На ее главной диагонале значениями являются стоимости реализации требования без учета реализации смежных. Прочие элементы в строке указывают на сколько изменится стоимость реализации требования, если будет реализовано соответствующее смежное требование.

$$c_{i, j} \in \mathbb{R} \quad i = \overline{1, n} \quad j = \overline{1, n}$$

Заметим, что значением элемента матрицы $C$ может являться и отрицательное число. Это будет означать, что реализация одного требования уменьшает стоимость реализации другого. Это характерно, например, для дополняющего друг друга функционала.

### Стоимость комплектаций

Рассмотрим результирующую стоимость $i$-го требования в комплектации $\tilde{l}$:

$$\sum_{j = 1}^{n}(c_{i, j} \cdot \dot{r}_{\tilde{l}, j})$$

Данное выражение описывает стоимость требования как если бы оно входило в комплектацию. Однако даже если само оно не реализовано по этой формуле оно может иметь ненулевую стоимость. Чтобы невилировать это обстоятельство данное выражение необходимо домножить на признак реализованности $i$-го требования:

$$\dot{r}_{\tilde{l}, i} \cdot \sum_{j = 1}^{n}(c_{i, \tilde{n}} \cdot \dot{r}_{\tilde{l}, j})$$

Стоимость одной комплектации - это суммарная стоимость всех реализованных в ней требований:

$$\sum^{n}_{i = 1} \big(\dot{r}_{\tilde{l}, i} \cdot \sum_{j = 1}^{n}(c_{i, j} \cdot \dot{r}_{\tilde{l}, j})\big) = \dot{R}_{\tilde{l}} \cdot C \cdot \dot{R}^{T}_{\tilde{l}}$$

Суммарная стоимость всех реализованных требований во всех комплектациях:

$$\sum(\dot{R}^{T}_{\tilde{l}} \cdot C \cdot \dot{R}_{\tilde{l}})$$

### Алгоритм определения стоимости комплектаций

Алгоритм определения :

1. Определяется состав комплектаций $P_{l \times k}$

2. Рассчитывается объем поставляемого кода в каждой из них:

$$\dot{F}_{m \times l} \gets X \cdot P^{T}$$

3. Выявляется состав реализованных требований в каждой из комплектаций:

$$\dot{R}_{l \times n} \gets f_{im}\big((Q \cdot \dot{F})^{T}\big)$$

4. Рассчитать стоимость комплектаций:

$$\sum_{\tilde{l}}(\dot{R}_{\tilde{l}} \cdot C \cdot \dot{R}^{T}_{\tilde{l}})$$

### Задача линейного программирования

Оптимизационная задача может быть решена как задача линейного программирования. С этой целью необходимо построить математическую модель: описать целевую функции и ограничения на значения задействованных переменных.

Для описания ограничений в общем виде используются следующие переменные:

$$\tilde{l} = \overline{1, l} \quad \tilde{n} = \overline{1, n} \quad \tilde{m} = \overline{1, m} \quad \tilde{k} = \overline{1, k}$$

Например, согласно условиям на значения элементов матрицы $X$ действуют следующие ограничения:

$$
\begin{cases}
    x_{1, 1} + x_{1, 2} + \cdots + x_{1, k} = 1 \\
    x_{2, 1} + x_{2, 2} + \cdots + x_{2, k} = 1 \\
    \cdots \\
    x_{m, 1} + x_{m, 2} + \cdots + x_{m, k} = 1
\end{cases}
$$

Используя введенные переменные вышеуказанные ограничения будут записаны так:

$$\sum^{k}_{i = 1} x_{\tilde{m}, i} = 1$$

Формирование целевой функции осуществляется при следовании этапам вышеописанных алгоритмов.

Следуя алгоритму определения состава комплектаций первые три шага не подразумевают наличия переменных, а значит для целевой функции важны значения матрицы $\hat{F}$:

$$\hat{F} \gets R \cdot Q \cdot \sum^{m}_{s = 0} D^{s} =
\begin{pmatrix}
    \hat{f}_{1, 1} & \hat{f}_{1, 2} & \cdots & \hat{f}_{1, m} \\
    \hat{f}_{2, 1} & \hat{f}_{2, 2} & \cdots & \hat{f}_{2, m} \\
    \vdots         & \vdots         & \ddots & \vdots         \\
    \hat{f}_{l, 1} & \hat{f}_{l, 2} & \cdots & \hat{f}_{l, m}
\end{pmatrix}
$$

Далее $\hat{F}$ необходимо умножить на $X$:

$$
P \gets \hat{F} \cdot X = 
\begin{pmatrix}
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{1, i} \cdot x_{i, 1}) & 
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{1, i} \cdot x_{i, 2}) &
    \cdots &
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{1, i} \cdot x_{i, k}) \\

    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{2, i} \cdot x_{i, 1}) & 
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{2, i} \cdot x_{i, 2}) &
    \cdots &
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{2, i} \cdot x_{i, k}) \\

    \vdots   & \vdots   & \ddots & \vdots   \\

    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{l, i} \cdot x_{i, 1}) & 
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{l, i} \cdot x_{i, 2}) &
    \cdots &
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{l, i} \cdot x_{i, k}) \\
\end{pmatrix}
$$

Для рассчета $P$ к каждому элементу матрицы необходимо применить $f_{in}(x)$, для которой так же необходимо выполнить линеаризацию. Для ее линеаризации используется метод big M. Следуя ему, вводится постоянная величина $M$ - условно большое число. Так же модель дополняется бинарной переменной $\alpha \in \{0, 1\}$, на которую действуют следующие ограничения:

$$
f_{in}(x) = 
\begin{cases}
    \alpha < x + 1 \\
    x \le M \cdot \alpha
\end{cases}
$$

Доказательство корректности ограничений методом разбора случаев приведено в таблице:

| $x$   | $\alpha$   | $f_{1}=(\alpha < x + 1)$ | $f_{2} = (x \le M \cdot \alpha)$ | $f_{1} \wedge f_{2}$
|     :-:      |  :-:  | :-:   |  :-:  |  :-:  |
|      0       |   0   | true  | true  | true  |
|      0       |   1   | false | true  | false |
|    (0;1)     |   0   | true  | false | false |
|    (0;1)     |   1   | true  | true  | true  |
|      1       |   0   | true  | false | false |
|      1       |   1   | true  | true  | true  |
| (1;$\infty$) |   0   | false | false | false |
| (1;$\infty$) |   1   | true  | true  | true  |

Для будущей программной реализации строгое неравенство должно быть заменено нестрогим. С этой целью вводится постоянная величина $1 / M$ - условно малое число. Тогда, например, выражение вида $a < b$ будет записано как $a + 1 / M \le b$.

Для линеаризации выражений матрицы $P$ требуется $l \cdot k$ дополнительных бинарных переменных $\alpha$, которые удобно представить в виде матрицы $\Alpha_{l \times k} = ||\alpha_{i, j}||$. Тогда выражение $f_{in}\big(\displaystyle \sum_{i = 1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}})\big)$ заменяется на $\alpha_{\tilde{l}, \tilde{k}}$, а модель дополняется ограничениями:
$$
\begin{cases}
    \alpha_{\tilde{l}, \tilde{k}} + 1 / M - \displaystyle \sum_{i  =1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}}) \le 0 \\
    \displaystyle \sum_{i = 1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}}) - M \cdot \alpha_{\tilde{l}, \tilde{k}} \le 0
\end{cases}
$$

Состав плагинов каждой из комплектаций:
$$P = 
\begin{pmatrix}
    \alpha_{1, 1} & \alpha_{1, 2} & \cdots & \alpha_{1, k} \\
    \alpha_{2, 1} & \alpha_{2, 2} & \cdots & \alpha_{2, k} \\
    \vdots        & \vdots        & \ddots & \vdots        \\
    \alpha_{l, 1} & \alpha_{l, 2} & \cdots & \alpha_{l, k}
\end{pmatrix}
$$

Cостав поставляемого кода:

$$
\dot{F} \gets X \cdot P^{T} =
\begin{pmatrix}
    \displaystyle
    \sum_{i = 1}^{k}(x_{1, i} \cdot \alpha_{1, i}) &
    \displaystyle
    \sum_{i = 1}^{k}(x_{1, i} \cdot \alpha_{2, i}) &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}(x_{1, i} \cdot \alpha_{l, i}) \\

    \displaystyle
    \sum_{i = 1}^{k}(x_{2, i} \cdot \alpha_{1, i}) &
    \displaystyle
    \sum_{i = 1}^{k}(x_{2, i} \cdot \alpha_{2, i}) &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}(x_{2, i} \cdot \alpha_{l, i}) \\

    \vdots & \vdots & \ddots & \vdots \\

    \displaystyle
    \sum_{i = 1}^{k}(x_{m, i} \cdot \alpha_{1, i}) &
    \displaystyle
    \sum_{i = 1}^{k}(x_{m, i} \cdot \alpha_{2, i}) &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}(x_{m, i} \cdot \alpha_{l, i}) \\

\end{pmatrix}
$$

Выражения в матрице $\dot{F}$ нелинейны. Однако в силу того, что переменные $x$ и $\alpha$ бинарные, каждое из этих выражений может быть приведено к линейному виду благодаря вводу дополнительной бинарной переменной $\beta \in \{0, 1\}$.  и дополнению модели следующими ограничениями:

$$
\begin{cases}
    x + \alpha \le \beta + 1 \\
    \beta \le x \\
    \beta \le \alpha
\end{cases}
$$

Доказательство корректности ограничений методом разбора случаев приведенов таблице:

| $x$ | $\alpha$ | $\beta$ | $f_{1}=(x + \alpha \le \beta + 1)$ | $f_{2} = (\beta \le x)$ | $f_{3} = (\beta \le \alpha)$ | $f_{1} \wedge f_{2} \wedge f_{3}$
| :-: | :-: | :-: | :-:   | :-:   |  :-:  |  :-:  |
|  0  |  0  |  0  | true  | true  | true  | true  |
|  0  |  0  |  1  | true  | false | false | false |
|  0  |  1  |  0  | true  | true  | true  | true  |
|  0  |  1  |  1  | true  | false | true  | false |
|  1  |  0  |  0  | true  | true  | true  | true  |
|  1  |  0  |  1  | true  | true  | false | false |
|  1  |  1  |  0  | false | true  | true  | false |
|  1  |  1  |  1  | true  | true  | true  | true  |

Для линеаризации выражений матрицы $\dot{F}$ требуется $l \cdot m \cdot k$ дополнительных бинарных переменных $\beta$, которые удобно представить в виде матрицы $\Beta_{l \times m \cdot k} = ||\beta_{i, j}||$. Тогда выражение $x_{\tilde{m}, \tilde{k}} \cdot \alpha_{\tilde{l}, \tilde{k}}$ заменяется на $\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}}$, а модель дополняется ограничениями:

$$
\begin{cases}
    x_{\tilde{m}, \tilde{k}} + \alpha_{\tilde{l}, \tilde{k}} - (\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} + 1) \le 0 \\
    \beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} - x_{\tilde{m}, \tilde{k}} \le 0 \\
    \beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} - \alpha_{\tilde{l}, \tilde{k}} \le 0 \\
\end{cases}
$$

Состав поставляемого кода с учетом введенных переменных:

$$
\dot{F} =
\begin{pmatrix}
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (1 - 1) + i, 1} &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (1 - 1) + i, 2} &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (1 - 1) + i, l} \\

    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (2 - 1) + i, 1} &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (2 - 1) + i, 2} &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (2 - 1) + i, l} \\

    \vdots & \vdots & \ddots & \vdots \\

    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (m - 1) + i, 1} &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (m - 1) + i, 2} &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (m - 1) + i, l} \\
\end{pmatrix}
$$

Определение состава реализованных требований в комплектациях:

$$\dot{R} \gets f_{im}\big((Q \cdot \dot{F})^{T}\big)$$

$$(Q \cdot \dot{F})^{T} = 
\begin{pmatrix}
    \displaystyle
    \sum_{i = 1}^{m}\big(q_{1, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 1}\big) &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{2, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 1}\big) &

    \cdots &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{n, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 1}\big) \\

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{1, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 2}\big) &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{2, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 2}\big) &

    \cdots &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{n, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 2}\big) \\

    \vdots & \vdots & \ddots & \vdots \\

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{1, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, l}\big) &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{2, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, l}\big) &

    \cdots &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{n, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, l}\big) \\

\end{pmatrix}
$$

Для функции $f_{im}$ необходимо выполнить линеаризацию. По аналогии с линеаризацией $f_{in}$ используется метод big M. Модель дополняется бинарной переменной $\gamma \in \{0, 1\}$, на которую действуют следующие ограничения:

$$f_{im}(x) =
\begin{cases}
    x \ge \gamma \\
    x < M \cdot \gamma + 1
\end{cases}
$$

Доказательство корректности ограничений методом разбора случаев приведено в таблице:

| $x$   | $\gamma$   | $f_{1}=(x \ge \gamma)$ | $f_{2} = (x < M \cdot \gamma + 1)$ | $f_{1} \wedge f_{2}$
|     :-:      |  :-:  | :-:   |  :-:  |  :-:  |
|      0       |   0   | true  | true  | true  |
|      0       |   1   | false | true  | false |
|    (0;1)     |   0   | true  | true  | true  |
|    (0;1)     |   1   | false | true  | false |
|      1       |   0   | true  | false | false |
|      1       |   1   | true  | true  | true  |
| (1;$\infty$) |   0   | true  | false | false |
| (1;$\infty$) |   1   | true  | true  | true  |

Для линеаризации выражений матрицы $(Q \cdot \dot{F})^{T}$ требуется $l \cdot n$ дополнительных бинарных переменных $\gamma$, которые удобно представить в виде матрицы $\Gamma_{l \times n} = ||\gamma_{i, j}||$. Тогда выражение $\displaystyle f_{im}(\sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big))$ заменяется на $\gamma_{\tilde{l}, \tilde{n}}$, а модель дополняется ограничениями:

$$
\begin{cases}
    \displaystyle
    \gamma_{\tilde{l}, \tilde{n}} - \sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big) \le 0 \\
    
    \displaystyle
    \sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big) + 1 / M - (M \cdot \gamma_{\tilde{l}, \tilde{n}} + 1) \le 0
\end{cases}
$$

Состав реализованных требований с учетом введенных переменных:

$$
\dot{R} = 
\begin{pmatrix}
    \gamma_{1, 1} & \gamma_{1, 2} & \cdots & \gamma_{1, n} \\
    \gamma_{2, 1} & \gamma_{2, 2} & \cdots & \gamma_{2, n} \\
    \vdots        & \vdots        & \ddots & \vdots \\
    \gamma_{l, 1} & \gamma_{l, 2} & \cdots & \gamma_{l, n}
\end{pmatrix}
$$

Стоимость реализованного $\tilde{n}$-го требования в $\tilde{l}$-й комплектации:

$$\dot{R}_{\tilde{l}, \tilde{n}} \cdot C_{\tilde{n}} \cdot \dot{R}^{T}_{\tilde{l}, \tilde{n}} = \gamma_{\tilde{l}, \tilde{n}} \cdot \sum_{i = 1}^{n}(c_{\tilde{n}, i} \cdot \gamma_{\tilde{l}, i}) = \sum^{n}_{i = 1}(c_{\tilde{n}, i} \cdot \gamma_{\tilde{l}, \tilde{n}} \cdot \gamma_{\tilde{l}, i})$$

Выражение $\gamma_{\tilde{l}, \tilde{n}} \cdot \gamma_{\tilde{l}, i}$ нелинейно. Однако в силу того, что переменные $\gamma$ бинарные это выражение может быть приведено к линейному виду благодаря вводу дополнительной бинарной переменной $\varphi \in \{0, 1\}$. Из ассоциативного свойства $\gamma_{\tilde{l}, \tilde{n}} \cdot \gamma_{\tilde{l}, i} = \gamma_{\tilde{l}, i} \cdot \gamma_{\tilde{l}, \tilde{n}}$ следует, что дополнительная переменная $\varphi$ может быть переиспользована. В силу этого для линеаризации выражения $\dot{R} \cdot C \cdot \dot{R}^{T}$ требуется $l \cdot n \cdot (n + 1) / 2$ дополнительных бинарных переменных $\varphi$, которые образуют матрицу $\varPhi_{l \times n \times n}$:

$$ \varPhi_{\tilde{l}} =
    \begin{pmatrix}
    \varphi_{\tilde{l}, 1, 1} & 0 & \cdots & 0 \\
    \varphi_{\tilde{l}, 2, 1} & \varphi_{\tilde{l}, 2, 2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    \varphi_{\tilde{l}, n, 1} & \varphi_{\tilde{l}, n, 2} & \cdots & \varphi_{\tilde{l}, n, n}
    \end{pmatrix}
$$

Тогда выражение $\gamma_{\tilde{l}, \tilde{n}} \cdot \gamma_{\tilde{l}, i}$ заменяется на $\varphi_{\tilde{l}, max(\tilde{n}, i), min(\tilde{n}, i)}$, а модель дополняется ограничениями:

$$
\begin{cases}
    \displaystyle
    \gamma_{\tilde{l}, \tilde{n}} + \gamma_{\tilde{l}, i} - (\varphi_{\tilde{l}, max(\tilde{n}, i), min(\tilde{n}, i)} + 1) \le 0 \\
    \varphi_{\tilde{l}, max(\tilde{n}, i), min(\tilde{n}, i)} - \gamma_{\tilde{l}, \tilde{n}} \le 0 \\
    \displaystyle
    \varphi_{\tilde{l}, max(\tilde{n}, i), min(\tilde{n}, i)} - \gamma_{\tilde{l}, i} \le 0
\end{cases}
$$

Суммарная стоимость реализованных требований в $\tilde{l}$ комплектации:

$$\sum^{n}_{i, j = 1}C_{i, j} \cdot \varphi_{\tilde{l}, max(i, j), min(i, j)}$$

Таким образом сформулирована задача линейного программирования:

|     | $min \displaystyle \sum_{\tilde{l}}\sum^{n}_{i, j = 1}C_{i, j} \cdot \varphi_{\tilde{l}, max(i, j), min(i, j)}$ | 
| :-: |  :-  | 
|s.t.  | $\displaystyle \gamma_{\tilde{l}, \tilde{n}} + \gamma_{\tilde{l}, i} - (\varphi_{\tilde{l}, max(\tilde{n}, i), min(\tilde{n}, i)} + 1) \le 0 \quad i = \overline{1, n}$ | 
|     | $\varphi_{\tilde{l}, max(\tilde{n}, i), min(\tilde{n}, i)} - \gamma_{\tilde{l}, \tilde{n}} \le 0 \quad i = \overline{1, n}$ | 
|     | $\varphi_{\tilde{l}, max(\tilde{n}, i), min(\tilde{n}, i)} - \gamma_{\tilde{l}, i} \le 0 \quad i = \overline{1, n}$ | 
|     | $\displaystyle \gamma_{\tilde{l}, \tilde{n}} - \sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big) \le 0$ | 
|     | $\displaystyle \sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big) + 1 / M - (M \cdot \gamma_{\tilde{l}, \tilde{n}} + 1) \le 0$ | 
|     |  $x_{\tilde{m}, \tilde{k}} + \alpha_{\tilde{l}, \tilde{k}} - (\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} + 1) \le 0$ | 
|     | $\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} - x_{\tilde{m}, \tilde{k}} \le 0$ | 
|     | $\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} - \alpha_{\tilde{l}, \tilde{k}} \le 0$ | 
|     | $\displaystyle \alpha_{\tilde{l}, \tilde{k}} + 1 / M - \sum_{i = 1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}}) \le 0$ |
|     |  $\displaystyle \sum_{i = 1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}}) - M \cdot \alpha_{\tilde{l}, \tilde{k}} \le 0$ |
|     |  $\displaystyle \sum^{k}_{i = 1} x_{\tilde{m}, i} = 1$ |
| | $\tilde{l} = \overline{1, l} \quad \tilde{n} = \overline{1, n} \quad \tilde{m} = \overline{1, m} \quad \tilde{k} = \overline{1, k}$ |
|w.b. | $X_{m \times k} = \|\|x\|\| \quad x \in \{0, 1\}$ |
|     | $\Alpha_{l \times k} = \|\|\alpha\|\| \quad \alpha \in \{0, 1\}$ |
|     | $\Beta_{l \times m \cdot k} = \|\|\beta\|\| \quad \beta \in \{0, 1\}$ |
|     | $\Gamma_{l \times n} = \|\|\gamma\|\| \quad \gamma \in \{0, 1\}$ |
|     | $\varPhi_{l \times n \times n} = \|\|\varphi\|\| \quad \varphi \in \{0, 1\}$ |
|     | $M >> 10$

Размер модели:

1. Количество переменных: $var\_count = m \cdot k + l \cdot \Big(k \cdot (m + 1) + n \cdot \big(0.5 \cdot (n + 1) + 1\big)\Big)$

2. Количество ограничений: $con\_count = m + l \cdot \big(k \cdot (3 \cdot m + 2) + n \cdot (1.5 \cdot (n + 1) + 2)\big)$

### Генетический алгоритм

Альтернативой решения оптимизационной задачи методом ее матиматической формализации является применение эвристических алгоритмов. В настоящей работе рассматривается применение генетического алгоритма.

При реализации генетического алгоритма нет необходимости проводить линеаризацию модели, однако необходимо определить функции:

1. оценки
2. селекции
3. кроссовера
4. мутации

Ранее была описана функция вычисления суммарной стоимости комплектаций. В качестве оценки может быть использовано противоположное значение:

$$fitness = -1 \cdot \sum_{\tilde{l}} (\dot{R}_{\tilde{l}} \cdot C \cdot \dot{R}^{T}_{\tilde{l}})$$

Для вычисления этого значения на каждой итерации должно производиться преобразование матрицы $X$ из генерируемого генетическим алгоритмом решения (подобранных значений генов). Рассматривалось два варианта генерируемого решения:

1. $\dot{X}_{1 \times m \cdot k} = ||\dot{x}_{i}||$ - $m \cdot k$ бинарных генов;

2. $\ddot{X}_{1 \times m} = ||\ddot{x}_{i}||$ - $m$ генов со значениями в диапазоне $[1; k]$.

Преобразование $\dot{X}$ в $X$:

$$x_{i, j} = \dot{x}_{i \cdot (k - 1) + j} \quad i = \overline{1, m} \quad j = \overline{1, k}$$

Преобразование $\ddot{X}$ в $X$:

$$X = Z$$

$$j = \ddot{x}_{i} \quad x_{i, j} = 1 \quad i = \overline{1, m}$$

Анализ вариантов генерируемого решения показал, что трансформация $\ddot{X}$ в $X$ гарантирует выполнения условия $\displaystyle \sum_{i = 1}^{m}X_{i} = 1$, кроме того длина вектора $\ddot{X}$ меньше чем длина $\dot{X}$, что упрощает поиск оптимального решения.

Анализ операторов генетического алгоритма не выявил лучший вариант для применения. Поэтому в рамках проводимого исследования были выполнены три реализации генетического алгоритма, включающие следующую конфигурацию:

| оператор | #1 | #2 | #3 |
| :-: | :-: | :-: | :-: |
| кол-во поколений | 1000 | 100 | 100 |
| кол-во хромосом | 4 | 4 | 40 |
| кол-во родительских решений | 2 | 2 | 20 |
| тип родительского выбора | steady-state selection | roulette wheel selection | stochastic universal selection |
| число сохраняемых родительских решений | 2 | 1 | 0 |
| тип кроссовера | одноточеный кроссовер | двухточечный кроссовер | равномерный кроссовер |
| тип мутации | swap mutation | inversion mutation | scramble mutation |
| % генов для мутации | 20 | 15 | 10 |

## Программная реализация

Программная реализация для решения оптимизационной задачи выполнена на языке программирования Python. Для ее математической формализации и построения задачи линейного программирования использовался модуль Pyomo. Для реализации генетического алгоритма использовался модуль PyGAD. Построение матриц, а так же действия над ними, например, умножние и транспонирование, осуществлялось с применинием модуля Numpy. Подготовка набора данных, сохранение его в виде набора ".csv" файлов и возможность его последующего считывания обеспечивает модуль Pandas.

Для проведения вычислительных экспериментов разработано хранилище:

1. Для каждого эксперимента выделяется директория в файловой системе и отмечается уникальным идентификатором

1. Дирректория включает исходные данные для проведения эксперимента в формате ".csv" и результаты его проведения в формате ".json"

1. Исходными данными являются матрицы $C$, $D$, $R$ и $Q$

1. Результаты проведения эксперимента записываются в файл "solutions.json", структура которого представляет собой массив структур формата, содержащего сведения о:
    
    - название применяемого в эксперименте MILP-решателя или метка конфигурации генетического алгоритма

    - значение функции оценки

    - потребное для выполнения вычислений время

Выполнение программы состоит из следующих основных этапов:

1. Подготовка данных

1. Решение оптимизационной задачи при помощи MILP-решателя или заданной конфигурацией генетического алгоритма

1. Преобразование результатов эксперимента в json структуру

1. Запись результата в файл "solutions.json". Данные будут дописаны в конец файла если для заданного MILP-решателя или метки конфигурации генетического алгоритма экперимент проводится впервые. Если экперимент проводится повторно информация будет обновлена.

Тестирование программы выполнялось для каждого из этапов изолировано друг от друга. Для каждого из них были определены тестировочные входные данные и тестовая реализация вызываемых в рамках работы этапа функций.

Во время разработки возникли проблемы с производительностью при больших значениях коэффициента $m$ для вычисления $\displaystyle \sum_{i = 0}^{m} D^{i}$. Была выполнена оптимизация, которая заключалась в вычислении значений результирующей матрицы заранее на этапе подготовки данных, а не во время выполнения программы. Исходные данные для работы программы дополнены значениями элементов этой матрицы.

На рисунке приведена обощенная схема компонентов разработанной программы.

![alt text](images/UML.png "UML диаграмма")

## Эксперименты и обсуждение

### Цели

Целью проведения экспериментов было сравнение эффективности применения генетических алгоритмов в решени оптимизационной задачи по сравнению с математической формализацией и последующим решением задачи линейного программирования. Ожидаемым результатом является вывод о корректности сформулированной гипотезы относительно разных методов решения оптимизационной задачи.

Была выдвинута гипотеза, что при увеличении размеров задачи линейного программирования (число ограничений и переменных) потребное время для работы MILP-решателей растет экспоненциально. Следовательно экспоненциально снижается эффективность их применения при увеличении коэффициентов $n$, $m$, $k$ и $l$. В то время как для генетического алгоритма эффективность снижается при увеличении не всех коэффициетов, а только $m$ и $k$. Значит в задачах большого размера с малыми значениями коэффициентов $m$ и $k$ применение генетического алгоритма должно быть более целесообразно.

<!-- Актуальизировать. Сделать, например, несколько таблиц для одного и того же номера эксперимента -->
### Данные

В экспериментах были задействованы MILP-решатели GNU Linear Programming Kit (glpk), COIN-OR branch and cut (cbc), а так же генетический алгоритм в $3$-х описанных ранее конфигурациях.

Для экспериментов были подготовлены синтезируемые данные. Данные были синтезированы так, чтобы для $i$-й комбинации коэффициентов $m \in [10; 25]$, $n \in [2; 2 \cdot m]$, $l \in [2; 2 \cdot n]$ и $k \in [2; m]$ выполнялось:

$$
\begin{cases}
    var\_count_{i} = 100 \cdot i \\
    con\_count_{i} \le con\_count_{i + 1}
\end{cases}
$$

Если было невозможно подобрать значения, удовлетворяющие описанным условиям, то синтез данных переходил к следующей итерации. Число комбинаций было ограничено значением $200$, всего было подобрано $193$ комбинации коэффициентов.

На основе подобранных коэффициентов выполнялась генерация матриц $C$, $D$, $R$ и $Q$, при этом действовали следующие ограничения:

1. На значения элементов матрицы $C$:
    - минимальное: $0$;
    - максимальное: $1$

1. На количество элементов в каждой строке матрицы $D$ равных $1$:
    - минимальное: $0$;
    - максимальное: $2$

1. На количество элементов в каждой строке матрицы $R$ равных $1$:
    - минимальное: $1$;
    - максимальное: $n$ 
    
1. Все строки матрицы $R$ должны быть уникальные

1. На количество элементов в каждой строке $Q$ с положительным значением:
    - мининальное: $1$;
    - максимальное: $2$;

Каждая комбинация коэффициентов использовалась для генерации $10$ вариантов матриц $C$, $D$, $R$ и $Q$. Таким образом всего было подготовлено $1930$ наборов данных.

В качестве демонстрации в таблице приведена часть информации о подобранных значениях коэффициентов в комбинациях.

| № комбинации | m | k | l | n |количество переменных|количество ограничений|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 1 | 13| 2 | 2 | 3 |100|225|
| 2 | 12| 5 | 2 | 2 |200|418|
| 3 | 15| 6 | 2 | 3 |300|627|
| 4 | 21| 6 | 2 | 2 |400|827|
| 5 | 18| 7 | 2 | 9 |500|1108|
|$\cdots$|$\cdots$|$\cdots$|$\cdots$|$\cdots$|$\cdots$|$\cdots$|
|190| 16| 3 | 32| 32|19600|57552|
|191| 25| 5 | 15| 47|19700|57970|
|192| 23| 8 | 16| 44|19800|58039|
|193| 20| 8 | 20| 39|19900|58300|
|194| 20| 11| 23| 34|20000|58325|

### Результаты

#### Потребное время

С целью демонстрации зависимости потребного времени от размера модели учитывалось не потребное время для выполнения каждого эксперимента, а усредненное по каждой комбинации коэффициентов.

На рисунке приведен график зависимости среднего времени выпонения от размера модели для решателя glpk.

![alt text](images/glpk_clean.png "glpk_clean")

График неравномерный, изменения скачкообразны и для упрощения анализа построен полифил второго порядка.

![alt text](images/glpk.png "glpk")

Аналогично для решателя cbc.

![alt text](images/cbc.png "cbc")

Результаты проведения эксперементов подтвердили ожидаемый экспоненциальный рост потребного времени MILP-решателям.

Так же подтверждается гипотеза, что потребное время для решения оптимизационной задачи генетическим алгоритм не зависит от размера модели (рисунок).

![alt text](images/durations.png "durations")

#### Значение функции оценки

Для вывода о целесообразности применения генетического алгоритма не достаточно опираться на данные о быстродействии решения. Требуется подтверждение объективной оценкой мера оптимизации, которая была достигнута при применении решения. В качестве такой оценки выступает суммарная стоимость комплектаций. Была собрана статистическая информация о том, в скольких случаях предлагалось лучшее решение по сравнению с конкурентами в каждом из $1930$ наборов данных. Лучшими считаются одно или несколько решений, которые показали меньшее значение стоимости.

Генетический алгоритм в конфигуации $3$ обеспичивал получение наиболее оптимального решения на значительно большем числе наборов данных по сравнению с аналогами.

![alt text](images/fitnesses.png "fitnesses")

### Заключение

В статье описано решение оптимизационной задачи поиска декомпозиции файлов исходного кода по плагинам по критерию минимальной стоимости формируемой комплектации. Предложено $2$ способа ее решения: математическая формализация с составлением задачи линейного программирования и применение генетического алгоритма. Сформулирована и подтверждена гипотеза об условиях целесообразности применения того или иного решения.

В дальнейших исследованиях предполагаается применение описаных механизмов для поиска оптимальной декомпозиции в программных решениях с открытым исходным кодом. Использование их в качестве базиса для формирования исходных данных оптимизационной задачи, ее решения и последующее перераспределение файлов исходного кода по плагинам. Целью такого исследования является получение практических результатов выработанной теории.
