# Оптимизация состава комплектаций программного обеспечения

## Введение

В настоящее время решение оптимизационных задач - востребованное направление в сфере информационных технологий. Решение таких задач востребовано для...

Имея сведения об объеме стоимостных издержек каждого из реализованных требований можно оценить суммарную их величину, примению для всей версии ПО вцелом.

Однако существует возможность поставки одной и той же версии ПО в различных комплектациях. При этом величины стоимостных издержек реализованного требования в разных комплектациях могут отличаться и зависеть от реализованных смежных требований.

Пример систем, обеспечивающих такую возможность - плагинные системы. В них интеграционной единицей, несущей конечный объем функционала, является плагин. Так, комплектациями являются различные комплекты плагинов.

В таких системах выделяют следующие сущности предметной области:

1. функциональные требования;
2. файлы исходного кода; 
3. плагины.

Сущности образуют друг с другом следующие связи:

1. в файлах исходного кода на языке программирования описана реализация функциональных требований;
2. файлы исходного имеют зависимости друг на друга и для осуществляения поставки все зависимости должны быть разрешены;
3. плагины содержат файлы исходного кода и обеспечивают интеграцию с плагинной средой выполнения.

Сущности и связи между ними образуют граф. Используя его, определяются комплектации плагинов. Каждая комплектация реализует уникальный минимальный объем требований.

Оптимизация состава комплектаций заключается в решении задачи оптимальной декомпозиции файлов исходного кода между плагинами. Критерием оптимальности является суммарная стоимость издержек всех сформированных комплектаций.

## Описание модели

### Граф

На рисунке приведен пример графа, построенного по описанию сущностей предметной области.

![alt text](images/graph.png "Граф")

Вершины в графе образуют:

1. $n$ функциональных требований;
2. $m$ файлов исходного кода;
3. $k$ плагинов.

$$n, m, k > 0 \quad n, m, k \in \mathbb{Z}$$

Ребра в графе образуются от:

1. трассируемости требований на файлы исходного кода;
2. наличия функциональных зависимостей между файлами исходного кода;
3. распределения файлов по плагинам.

### Трассируемость требований на файлы исходного кода

Трассируемость требований на файлы исходного кода описывает связь требований и файлов. Связь характеризуется степенью ответственности файла для реализации требования.

Эти связи можно представить в виде матрицы $T_{n \times m} = ||t_{i, j}||$. В ней номер строки - это индекс требования. Номер столбца - индекс файла исходного кода. Элементы $T$ описывают долю ответственности файла для реализации требования. 

Каждый файл может быть необходим для реализации одного или нескольких требований, а каждое требование реализовано в одном или нескольких файлах. Допускается, что могут быть файлы, которые не задействованы в реализации хотябы одного требования, но каждое требование должно быть реализовано. За признак реализованности положена сумма соответствующих элементов матрицы, она должна быть равна $1$. Вследствие этого, элементы матрицы $T$ удовлетворяют следующим условиям:

$$0 \le t_{i, j} \le 1 \quad \sum T_{i} = 1 \quad i = \overline{1, n} \quad j = \overline{1, m}$$

### Зависимости между файлами исходного кода

Файлы исходного кода имеют зависимости между друг другом. Зависимость одного файла от другого образует направленную связь, т.е. если первый файл зависит от второго, то второй необязательно зависит от первого.

Такие связи можно представить в виде матрицы бинарных отношений $D_{m \times m} = ||d_{i, j}||$. В ней номера строк и столбцов соответствуют индексам файлов исходного кода. Если $i$-й фал имеет зависимость на $j$-й, то $d_{i, j} = 1$. Иначе $d_{i, j} = 0$. Полагается, что файл не зависит сам от себя, поэтому значения элементов на главной диагонале равны $0$.

### Разрешение зависимостей между файлами исходного кода

Для возможности включения в поставку файла исходного кода необходимо разрешить его зависимости. Разрешение зависимостей подразумевает включение в поставку тех файлов, от которых зависит изначальный. Для дополнительно включаемых файлов так же должны быть разрешены их зависимости.

Вектор $F_{1 \times m} = ||f_{i}||$ описывает полезные к поставке файлы исходного кода. Если $i$-й файл полезен $f_{i} > 0$. Иначе $f_{i} = 0$. 

Заметим, что если файл полезен, то нет обязательного условия на равенство значения элемента вектора. Достаточно чтобы его значение было положительным числом.

Зависимости полезных фалов вычисляются по формуле:

$$F' = F \cdot D$$

Их зависимости вычисляются как:

$$F'' = F' \cdot D = F \cdot D \cdot D = F \cdot D^{2}$$

Очевидно, что

$$F^{(i)} = F \cdot D^{i}$$

Заметим, что максимальная глубина зависимостей не может превышать значение $m$, поэтому досточно разрешить зависимости до этого значения глубины.

Вектор $\hat{F}_{1 \times m} = ||\hat{f}_{i}||$ описывает полезные файлы с учетом разрешения их зависимостей. Для вычисления его значений необходимо просуммировать вектор полезных файлов и каждый из векторов разрешения зависимостей.

$$\hat{F} = F + F' + F'' + ... + F^{(m)} = F + F \cdot D + F \cdot D^{2} + ... + F \cdot D^{m} = F \cdot (E + \sum^{m}_{i = 1}D^{i}) = F \cdot (D^{0} + \sum^{m}_{i = 1}D^{i}) = F \cdot \sum^{m}_{i = 0}D^{i}$$

Для значений вектора $\hat{F}$ так же как и для значений вектора $F$ характерно, что отсутствует ограничение на положительное значение.

### Распределение файлов по плагинам



$$\varPhi \quad \varphi \quad \Alpha \quad \alpha \quad \Beta \quad \beta \quad \Gamma \quad \gamma$$

Алгоритм определения состава комплектации:

1. определить состав полезных требований
2. определить какие файлы исходного кода реализуют полезные требования
3. разрешить их зависимости
4. определить, какие плагины должны войти в комплектацию

Алгоритм определения реализованных требований в рамках комплектации:

1. определить состав комплектации
2. определить, какие файлы исходного кода должны быть поставлены
3. определить, какие требования будут реализованы в рамках комплектации

### Рассчет стоимости

### Линеаризация

### Генетический алгоритм