# Оптимизация состава комплектаций программного обеспечения

## Введение

В настоящее время решение оптимизационных задач - востребованное направление в сфере информационных технологий. Решение таких задач востребовано для...

Имея сведения об объеме стоимостных издержек каждого из реализованных требований можно оценить суммарную их величину, примению для всей версии ПО вцелом.

Однако существует возможность поставки одной и той же версии ПО в различных комплектациях. При этом величины стоимостных издержек реализованного требования в разных комплектациях могут отличаться и зависеть от реализованных смежных требований.

Пример систем, обеспечивающих такую возможность - плагинные системы. В них интеграционной единицей, несущей конечный объем функционала, является плагин. Так, комплектациями являются различные комплекты плагинов.

В таких системах выделяют следующие сущности предметной области:

1. функциональные требования;
2. файлы исходного кода; 
3. плагины.

Сущности образуют друг с другом следующие связи:

1. в файлах исходного кода на языке программирования описана реализация функциональных требований;
2. файлы исходного имеют зависимости друг на друга и для осуществляения поставки все зависимости должны быть разрешены;
3. плагины содержат файлы исходного кода и обеспечивают интеграцию с плагинной средой выполнения.

Сущности и связи между ними образуют граф. Используя его, определяются комплектации плагинов. Каждая комплектация реализует уникальный минимальный объем требований.

Оптимизация состава комплектаций заключается в решении задачи оптимальной декомпозиции файлов исходного кода между плагинами. Критерием оптимальности является суммарная стоимость издержек всех сформированных комплектаций.

## Описание модели

### Граф

На рисунке приведен пример графа, построенного по описанию сущностей предметной области.

![alt text](images/graph.png "Граф")

Вершины в графе образуют:

1. $n$ функциональных требований;
2. $m$ файлов исходного кода;
3. $k$ плагинов.

$$n, m, k > 0 \quad n, m, k \in \mathbb{Z}$$

Ребра в графе образуются от:

1. трассируемости требований на файлы исходного кода;
2. наличия функциональных зависимостей между файлами исходного кода;
3. распределения файлов по плагинам.

### Полезные требования
Полезных требований может быть $l$ комбинаций. Полезные требования образуют матрицу $R_{l \times n}$. В ней номер строки соответствует номеру комбинации полезных требований. Номер столбца соответствует индексу требования. Если в рамках $i$-й комбинации $j$-е требование полезно $r_{i, j} = 1$. Иначе $r_{i, j} = 0$.

$$r_{i, j} \in \{0, 1\} \quad i = \overline{1, l} \quad j= \overline{1, n}$$

### Трассируемость требований на файлы исходного кода

Трассируемость требований на файлы исходного кода описывает связь требований и файлов. Связь характеризуется степенью ответственности файла для реализации требования.

Эти связи можно представить в виде матрицы $T_{n \times m} = ||t_{i, j}||$. В ней номер строки - это индекс требования. Номер столбца - индекс файла исходного кода. Элементы $T$ описывают долю ответственности файла для реализации требования. 

Каждый файл может быть необходим для реализации одного или нескольких требований, а каждое требование реализовано в одном или нескольких файлах. Допускается, что могут быть файлы, которые не задействованы в реализации хотябы одного требования, но каждое требование должно быть реализовано. За признак реализованности положена сумма соответствующих элементов матрицы, она должна быть равна $1$. Вследствие этого, элементы матрицы $T$ удовлетворяют следующим условиям:

$$0 \le t_{i, j} \le 1 \quad \sum T_{i} = 1 \quad i = \overline{1, n} \quad j = \overline{1, m}$$

### Зависимости между файлами исходного кода

Файлы исходного кода имеют зависимости между друг другом. Зависимость одного файла от другого образует направленную связь, т.е. если первый файл зависит от второго, то второй необязательно зависит от первого.

Такие связи можно представить в виде матрицы бинарных отношений $D_{m \times m} = ||d_{i, j}||$. В ней номера строк и столбцов соответствуют индексам файлов исходного кода. Если $i$-й фал имеет зависимость на $j$-й, то $d_{i, j} = 1$. Иначе $d_{i, j} = 0$. Полагается, что файл не зависит сам от себя, поэтому значения элементов на главной диагонале равны $0$.

$$d_{i, j} \in \{0, 1\} \quad d_{\tilde{m}, \tilde{m}} = 0 \quad i = \overline{1, m} \quad j = \overline{1, m} \quad \tilde{m} = \overline{1, m}$$

### Разрешение зависимостей между файлами исходного кода

Для возможности включения в поставку файла исходного кода необходимо разрешить его зависимости. Разрешение зависимостей подразумевает включение в поставку тех файлов, от которых зависит изначальный. Для дополнительно включаемых файлов так же должны быть разрешены их зависимости.

Вектор $F_{1 \times m} = ||f_{i}||$ описывает полезные к поставке файлы исходного кода. Номер стобца соответствует индексу файла. Если $i$-й файл полезен $f_{i} > 0$. Иначе $f_{i} = 0$. 

Заметим, что если файл полезен, то нет обязательного условия на равенство значения элемента вектора. Достаточно чтобы его значение было положительным числом.

Зависимости полезных файлов:

$$F' \gets F \cdot D$$

Их зависимости:

$$F'' \gets F' \cdot D = F \cdot D \cdot D = F \cdot D^{2}$$

Очевидно, что

$$F^{(i)} \gets F \cdot D^{i}$$

Заметим, что максимальная глубина зависимостей не может превышать значение $m$, поэтому досточно разрешить зависимости до этого значения глубины.

Вектор $\hat{F}_{1 \times m} = ||\hat{f}_{i}||$ описывает полезные файлы с учетом разрешения их зависимостей. Аналогично вектору $F$ в нем номер столбца соответствует индексу файла. Для вычисления его значений необходимо просуммировать вектор полезных файлов и каждый из векторов разрешения зависимостей.

$$\hat{F} \gets F + F' + F'' + ... + F^{(m)} = F + F \cdot D + F \cdot D^{2} + ... + F \cdot D^{m} = F \cdot (E + \sum^{m}_{i = 1}D^{i}) = F \cdot (D^{0} + \sum^{m}_{i = 1}D^{i}) = F \cdot \sum^{m}_{i = 0}D^{i}$$

Для значений вектора $\hat{F}$ так же как и для значений вектора $F$ характерно, что отсутствует ограничение на положительное значение.

### Распределение файлов по плагинам
Файлы исходного кода распределены по плагинам. Для включения в поставку файла необходимо включить в комплектацию плагин, который этот файл содержит. Включенный в комплектацию плагин добавляет в поставку все файлы, которые содержит.

Распределение файлов по плагинам образуют матрицу бинарных отношений $X_{m \times k} = ||x_{i, j}||$. В ней номер строки соответствует индексу файла, номер столбца - индексу плагина. Если $i$-й файл относится к $j$-му плагину, то $x_{i, j} = 1$. Иначе $x_{i, j} = 0$.

Плагин может включать несколько файлов, а один файл не может относиться одновременно к разным плагинам. Каждый файл должен относиться к какому-либо плагину. Не каждый плагин должен включать хотя бы один файл. Именно поиск распределения файлов по плагинам предполагается в оптимизационной задаче. Вследствие этого элементы матрицы $X$ удовлетворяют следующим условиям:

$$x_{i, j} \in \{0, 1\} \quad \sum X_{i} = 1 \quad i = \overline{1, m} \quad j = \overline{1, k}$$

### Поставляемые требования в комплектациях

В результате обхода каждым из $l$ векторов матрицы $R$ образуется матрица бинарных отношений $\dot{R}_{l \times n} = ||\dot{r}_{i, j}||$. В ней номер строки соответствует индексу комплектации. Номер столбца соответствует индексу требования. Если в рамках $i$-ой комплектации $j$-е требование будет реализовано $\dot{r}_{i, j} = 1$. Иначе $\dot{r}_{i, j} = 0$.

$$\dot{r}_{i, j} \in \{0, 1\} \quad i = \overline{1, l} \quad j = \overline{1, n}$$

Для описания алгоритма рассчета значений матрицы $\dot{R}$ необходимо ввести вспомогательные функции:

1. функция включения $f_{in}$
2. функция реализации $f_{im}$

Функция включения $f_{in}$ применяется ко всем элементам матрицы по следующему правилу:

$$f_{in}(x) = \begin{cases}
    0 & \quad \text{если } x = 0 \\
    1 & \quad \text{если } x > 0
\end{cases}$$

Функция реализации $f_{im}$ применяется ко всем элементам матрицы по следующему правилу:

$$f_{im}(x) = \begin{cases}
    0 & \quad \text{если } x < 1 \\
    1 & \quad \text{если } x \ge 1
\end{cases}$$

Рассчет значений матрицы $\dot{R}$ производится построчно. Алгоритм рассчета значений $\dot{R}_{i}$ следующий:

1. Вычислить состав файлов исходного кода, реализующих полезные требования:
$$F_{1 \times m} \gets R_{i} \cdot T$$

2. Разрешить их зависимости:

$$\hat{F}_{1 \times m} \gets F \cdot \sum^{m}_{j = 0} D^{j}$$

*Примечание: для программной реализации удобно применить к матрице $\hat{F}$ функцию $f_{in}$.*

3. Определить поставляемый состав плагинов:

$$P_{1 \times k} \gets f_{in}(\hat{F} \cdot X)$$

4. Определить все файлы исходного кода, которые должны быть поставлены в каждой из комбинаций:

$$\dot{F}_{m \times 1} \gets X \cdot P^{T}$$

5. Определить реализованные требования:

$$\dot{R}_{i} \gets f_{im}(T \cdot \dot{F})$$

### Обеспечение уникальности комплектаций

В процессе решения задачи поиска реализованных требований и формирования матрицы $\dot{R}$ неисключено появление дублирующих строк. Это сигнал о том, что разные комбинации полезных требований при заданном распределении файлов по плагинам дают одинаковый объем реализованных требований. Из этого следует, что происходит дублирование комплектаций плагинов. Для оптимизации стоимости уникальных комплектаций их необходимо определить.

Идея обеспечения уникальности состоит в следующем:

1. представить строки матрицы $\dot{R}$ как двоичные числа;
2. преобразовать двоичное число в десятичное;
3. использовать это десятичное число как номер строки в вспомогательной матрице.

Число уникальных комплектаций не может превышать $2^{n}$. Поэтому объявляется нулевая матрица $U_{2^{n}, n} = Z$.

Представление значений $R_{i}$ в виде десятичного числа производится по следующей формуле:

$$index = \sum^{n}_{j = 1}(R_{i, n - j} \cdot 2^{n - j})$$

$$U_{index} = R_{i}$$

### Рассчет стоимости уникальных комплектаций

На стоимость комплектации влияют:

1. состав реализованных в комплектации требований
2. величины изменения стоимости от их реализации

Состав реализованных требований описывает вектор бинарных отношений $\dot{R}_{n \times 1} = ||\dot{r}_{i}||$. Номер строки соответствует индексу требования. Если $i$-е требование реализовано $\dot{r}_{i} = 1$. Иначе $\dot{r}_{i} = 0$.



Стоимость требования в комплектации - это сумма собственной стоимости требования и величин ее изменения $\dot{c}_{i}$, где $i$ - индекс требования. Суммировать необходимо не все величины изменения, а лишь те, что соответствуют индексам реализованных в комплектации требований. 

Величины изменения стоимости реализации требований описывает матрица $C_{n \times n} = ||c_{i, j}||$. В ней номера строк и столбцов соответствуют индексам требований. На ее главной диагонале значениями являются стоимости реализации требования без учета реализации смежных. Прочие элементы в строке указывают на сколько изменится стоимость реализации требования, если будет реализовано соответствующее смежное требование.

$$c_{i, j} \in \mathbb{R} \quad i = \overline{1, n} \quad j = \overline{1, n}$$

Заметим, что значением элемента матрицы $C$ может являться и отрицательное число. Это будет означать, что реализация одного требования уменьшает стоимость реализации другого. Это характерно, например, для дополняющего друг друга функционала.

Рассмотрим результирующую стоимость $i$-го требования:

$$\dot{r}_{1} \cdot c_{i, 1} + \dot{r}_{2} \cdot c_{i, 2} + ... + \dot{r}_{n} \cdot c_{i, n}$$

Данная формула описывает стоимость требования как если бы оно входило в комплектацию. Однако если само оно не реализовано по этой формуле оно может иметь ненулевую стоимость. Чтобы невилировать это обстоятельство данное выражение необходимо домножить на признак реализованности $i$-го требования:

$$\dot{r}_{i} \cdot (\dot{r}_{1} \cdot c_{i, 1} + \dot{r}_{2} \cdot c_{i, 2} + ... + \dot{r}_{n} \cdot c_{i, n})$$

Стоимость комплектации - это суммарная стоимость всех реализованных в ней требований:

$$\dot{r}_{1} \cdot (\dot{r}_{1} \cdot c_{1, 1} + \dot{r}_{2} \cdot c_{1, 2} + ... + \dot{r}_{n} \cdot c_{1, n}) + \dot{r}_{2} \cdot (\dot{r}_{1} \cdot c_{2, 1} + \dot{r}_{2} \cdot c_{2, 2} + ... + \dot{r}_{n} \cdot c_{2, n}) + ... + \dot{r}_{n} \cdot (\dot{r}_{1} \cdot c_{n, 1} + \dot{r}_{2} \cdot c_{n, 2} + ... + \dot{r}_{n} \cdot c_{n, n})$$

Или в виде операций над матрицами:

$$\dot{R}^{T} \cdot C \cdot \dot{R}$$

Заявляться может $l$ комбинаций полезных требований. Не обязательно, что они преобразуются в $l$ комплектаций, но результирующее их число точно не будет превышать $l$. Поэтому 

$$\varPhi \quad \varphi \quad \Alpha \quad \alpha \quad \Beta \quad \beta \quad \Gamma \quad \gamma$$

Алгоритм определения состава комплектации:

1. определить состав полезных требований
2. определить какие файлы исходного кода реализуют полезные требования
3. разрешить их зависимости
4. определить, какие плагины должны войти в комплектацию

Алгоритм определения реализованных требований в рамках комплектации:

1. определить состав комплектации
2. определить, какие файлы исходного кода должны быть поставлены
3. определить, какие требования будут реализованы в рамках комплектации

### Рассчет стоимости

### Целевая функция

### Линелиаризация

### Генетический алгоритм