# Оптимизация состава комплектаций программного обеспечения

## Введение

В настоящее время решение оптимизационных задач - востребованное направление в сфере информационных технологий. Решение таких задач востребовано для...

Имея сведения об объеме стоимостных издержек каждого из реализованных требований можно оценить суммарную их величину, примению для всей версии ПО вцелом.

Однако существует возможность поставки одной и той же версии ПО в различных комплектациях. При этом величины стоимостных издержек реализованного требования в разных комплектациях могут отличаться и зависеть от реализованных смежных требований.

Пример систем, обеспечивающих такую возможность - плагинные системы. В них интеграционной единицей, несущей конечный объем функционала, является плагин. Так, комплектациями являются различные комплекты плагинов.

В таких системах выделяют следующие сущности предметной области:

1. функциональные требования;
2. файлы исходного кода; 
3. плагины.

Сущности образуют друг с другом следующие связи:

1. в файлах исходного кода на языке программирования описана реализация функциональных требований;
2. файлы исходного имеют зависимости друг на друга и для осуществляения поставки все зависимости должны быть разрешены;
3. плагины содержат файлы исходного кода и обеспечивают интеграцию с плагинной средой выполнения.

Сущности и связи между ними образуют граф. Используя его, определяются комплектации плагинов. Каждая комплектация реализует уникальный минимальный объем требований.

Оптимизация состава комплектаций заключается в решении задачи оптимальной декомпозиции файлов исходного кода между плагинами. Критерием оптимальности является суммарная стоимость издержек всех сформированных комплектаций.

## Описание модели

### Граф

На рисунке приведен пример графа, построенного по описанию сущностей предметной области.

![alt text](images/graph.png "Граф")

Вершины в графе образуют:

1. $n$ функциональных требований;
2. $m$ файлов исходного кода;
3. $k$ плагинов.

$$n, m, k > 0 \quad n, m, k \in \mathbb{Z}$$

Ребра в графе образуются от:

1. трассируемости требований на файлы исходного кода;
2. наличия функциональных зависимостей между файлами исходного кода;
3. распределения файлов по плагинам.

### Полезные требования
Полезных требований может быть $l$ комбинаций. Каждой из таких комбинаций должна соответствовать комплектация, которая обеспечивает выполнение полезных требований. Соответственно должно быть $l$ комплектаций. 

Полезные требования образуют матрицу $R_{l \times n} = ||r_{i, j}||$. В ней номер строки соответствует номеру комплектации. Номер столбца соответствует индексу требования. Если в рамках $\tilde{l}$-й комплектации $\tilde{n}$-е требование полезно $r_{i, j} = 1$. Иначе $r_{i, j} = 0$.

$$r_{i, j} \in \{0, 1\} \quad \sum R_{i} \ge 1 \quad i = \overline{1, l} \quad j= \overline{1, n}$$

### Трассируемость требований на файлы исходного кода

Трассируемость требований на файлы исходного кода описывает связь требований и файлов. Связь характеризуется степенью ответственности файла для реализации требования.

Эти связи можно представить в виде матрицы $Q_{n \times m} = ||q_{i, j}||$. В ней номер строки - это индекс требования. Номер столбца - индекс файла исходного кода. Элементы $Q$ описывают долю ответственности файла для реализации требования. 

Каждый файл может быть необходим для реализации одного или нескольких требований, а каждое требование реализовано в одном или нескольких файлах. Допускается, что могут быть файлы, которые не задействованы в реализации хотябы одного требования, но каждое требование должно быть реализовано. За признак реализованности положена сумма соответствующих элементов матрицы, она должна быть равна $1$. Вследствие этого, элементы матрицы $Q$ удовлетворяют следующим условиям:

$$0 \le q_{i, j} \le 1 \quad \sum Q_{i} = 1 \quad i = \overline{1, n} \quad j = \overline{1, m}$$

### Полезные файлы исходного кода

Матрица $F_{l \times m} = ||f_{i, j}||$ описывает полезные к поставке файлы исходного кода в каждой из комплектаций. Номер строки соответствует номеру комплектации. Номер столбца соответствует индексу файла. Если в рамках $i$-й комплектации $j$-й файл полезен $f_{i, j} > 0$. Иначе $f_{i, j} = 0$.

Заметим, что если файл полезен, то нет обязательного условия на равенство значения элемента матрицы. Достаточно чтобы его значение было положительным числом.

$$f_{i, j} \ge 0 \quad i = \overline{1, l} \quad j = \overline{1, m}$$

Матрицы $F$ и $R$ связаны друг с другом через $Q$:

$$F = R \cdot Q$$

### Зависимости между файлами исходного кода

Файлы исходного кода имеют зависимости между друг другом. Зависимость одного файла от другого образует направленную связь, т.е. если первый файл зависит от второго, то второй необязательно зависит от первого.

Такие связи можно представить в виде матрицы бинарных отношений $D_{m \times m} = ||d_{i, j}||$. В ней номера строк и столбцов соответствуют индексам файлов исходного кода. Если $i$-й фал имеет зависимость на $j$-й, то $d_{i, j} = 1$. Иначе $d_{i, j} = 0$. Полагается, что файл не зависит сам от себя, поэтому значения элементов на главной диагонале равны $0$.

$$d_{i, j} \in \{0, 1\} \quad d_{i, i} = 0 \quad i = \overline{1, m} \quad j = \overline{1, m}$$

### Разрешение зависимостей между файлами исходного кода

Для возможности включения в поставку файла исходного кода необходимо разрешить его зависимости. Разрешение зависимостей подразумевает включение в поставку тех файлов, от которых зависит изначальный. Для дополнительно включаемых файлов так же должны быть разрешены их зависимости.

Зависимости полезных файлов:

$$F' \gets F \cdot D$$

Их зависимости:

$$F'' \gets F' \cdot D = F \cdot D \cdot D = F \cdot D^{2}$$

Очевидно, что:

$$F^{(\sigma)} \gets F \cdot D^{\sigma}$$

Заметим, что максимальная глубина зависимостей не может превышать значение $m$, поэтому досточно разрешить зависимости до этого значения глубины.

Матрица $\hat{F}_{l \times m} = ||\hat{f}_{i, j}||$ описывает полезные файлы с учетом разрешения их зависимостей. Аналогично матрице $F$ в ней номер строки соответствует номеру комплектации, а номер столбца - индексу файла. Для вычисления значений матрицы необходимо просуммировать матрицу полезных файлов и каждую из матриц разрешения зависимостей.

$$\hat{F} \gets F + F' + F'' + ... + F^{(m)} = F + F \cdot D + F \cdot D^{2} + ... + F \cdot D^{m} = F \cdot (E + \sum^{m}_{i = 1}D^{i}) = F \cdot (D^{0} + \sum^{m}_{i = 1}D^{i}) = F \cdot \sum^{m}_{i = 0}D^{i}$$

Для значений матрицы $\hat{F}$ так же как и для значений матрицы $F$ характерно, что отсутствует ограничение на положительное значение.

$$\hat{f}_{i, j} \ge 0 \quad i = \overline{1, l} \quad j = \overline{1, m}$$

В результате вычислений элементы матрицы $\hat{F}$ могут принимать на столько большие значения, что дальнейшее с ними взаимодействие может быть затруднено. С целью нивелирования данного обстоятельства можно изменить значения матрицы $\hat{F}$ преобразовав их к бинарным отношениям применив следующую функцию:

$$f_{in}(x) = \begin{cases}
    0 & \quad \text{если } x = 0 \\
    1 & \quad \text{если } x > 0
\end{cases}$$

### Распределение файлов по плагинам
Файлы исходного кода распределены по плагинам. Для включения в поставку файла необходимо включить в комплектацию плагин, который этот файл содержит. Включенный в комплектацию плагин добавляет в поставку все файлы, которые содержит.

Распределение файлов по плагинам образуют матрицу бинарных отношений $X_{m \times k} = ||x_{i, j}||$. В ней номер строки соответствует индексу файла, номер столбца - индексу плагина. Если $i$-й файл относится к $j$-му плагину, то $x_{i, j} = 1$. Иначе $x_{i, j} = 0$.

Плагин может включать несколько файлов, а один файл не может относиться одновременно к разным плагинам. Каждый файл должен относиться к какому-либо плагину. Не каждый плагин должен включать хотя бы один файл. Именно поиск распределения файлов по плагинам предполагается в оптимизационной задаче. Вследствие этого элементы матрицы $X$ удовлетворяют следующим условиям:

$$x_{i, j} \in \{0, 1\} \quad \sum X_{i} = 1 \quad i = \overline{1, m} \quad j = \overline{1, k}$$

### Комплектации плагинов

Комплектация плагинов обеспечивает поставку полезного функционала и минимизирует поставку бесполезного. Каждая комплектация включает от $1$ до $k$ плагинов.

Комплектации плагинов для каждой комбинации полезных требований образуют матрицу бинарных отношений $P_{l \times k} = ||p_{i, j}||$. Номер строки соответсвует номеру комплектации. Номер столбца соответствует индексу плагина. Если $j$-й плагин должен быть включен в $i$-ю комплектацию $p_{i, j} = 1$. Иначе $p_{i, j} = 0$.

$$p_{i, j} \in \{0, 1\} \quad \sum P_{i} \ge 1 \quad i = \overline{1, l} \quad j = \overline{1, k}$$

Матрицы $P$ и $\hat{F}$ связаны друг с другом через $X$:

$$P \gets f_{in}(\hat{F} \cdot X)$$

### Алгоритм определения состава комплектаций

Алгоритм определения состава комплектаций:

1. ЛПР формирует комбинации полезных требоний $R_{l \times n}$.
2. Для каждой из них определяются полезные файлы исходного кода:

$$F_{l \times m} \gets R \cdot Q$$

3. Составляется матрица учитывающая полезные файлы и их разрешенные зависимости:

$$\hat{F}_{l \times m} \gets F \cdot \sum^{m}_{i = 0}D^{i}$$

4. Определяется состав плагинов каждой из комплектаций:

$$P_{l \times k} \gets f_{in}(\hat{F} \cdot X)$$

### Поставляемый код

Поставляемый код - это весь код, который относится к поставляемым в рамках комплектации плагинам. Его описывает матрица бинарных отношений $\dot{F}_{m \times l} = ||\dot{f}_{i, j}||$. В ней номер строки соответствует индексу файла. Номер строки соответствует номеру комплектации.

$$\dot{f}_{i, j} \in \{0, 1\} \quad i = \overline {1, m} \quad j = \overline{1, l}$$

Матрицы $\dot{F}$ и $P$ связаны друг с другом через $X$:

$$\dot{F} \gets X \cdot P^{T}$$

Примечательно, что ограничения значений матриц $X$ и $P$ обеспечивают бинарность отношений $\dot{F}$. Благодаря этому отсутсвует необходимость дополнительной бработки ее значений, например, с использованием функции $f_{in}$.

### Реализованные требования

Реализованным называется такое требование, для которого поставлен весь код, который задействован в его реализации. Состав реализованных требований влияет на стоимость комплектации.

Для определения того, поставляется ли весь код, ответственный за реализацию требования, применяется функция:

$$f_{im}(x) = \begin{cases}
    0 & \quad \text{если } x < 1 \\
    1 & \quad \text{если } x \ge 1
\end{cases}$$

Матрица бинарных отношений $\dot{R}_{l \times n} = ||\dot{r}_{i, j}||$ описывает состав реализованных требований в каждой из комплектаций. Номер строки соответствует номеру комплектации. Номер столбца соответствует индексу требования.

$$\dot{r}_{i, j} \in \{0, 1\} \quad i = \overline{1, l} \quad j = \overline{1, n}$$

Матрицы $\dot{R}$ и $\dot{F}$ связаны друг с другом через $Q$:

$$\dot{R} \gets f_{im}\big((Q \cdot \dot{F})^{T}\big) = f_{im}\Bigg(\bigg[Q \cdot X \cdot f_{in}\Big(\big[\hat{F} \cdot X\big]^{T}\Big)\bigg]^{T}\Bigg)$$

### Стоимостные характеристики

Стоимость реализованного требования не является постоянной величиной и может быть изменена в зависимости от реализации в комплектации смежных требований.

Величины изменения стоимости реализации требований описывает матрица $C_{n \times n} = ||c_{i, j}||$. В ней номера строк и столбцов соответствуют индексам требований. На ее главной диагонале значениями являются стоимости реализации требования без учета реализации смежных. Прочие элементы в строке указывают на сколько изменится стоимость реализации требования, если будет реализовано соответствующее смежное требование.

$$c_{i, j} \in \mathbb{R} \quad i = \overline{1, n} \quad j = \overline{1, n}$$

Заметим, что значением элемента матрицы $C$ может являться и отрицательное число. Это будет означать, что реализация одного требования уменьшает стоимость реализации другого. Это характерно, например, для дополняющего друг друга функционала.

### Стоимость комплектаций

Рассмотрим результирующую стоимость $i$-го требования в комплектации $\tilde{l}$:

$$\sum_{j = 1}^{n}(c_{i, j} \cdot \dot{r}_{\tilde{l}, j})$$

Данное выражение описывает стоимость требования как если бы оно входило в комплектацию. Однако даже если само оно не реализовано по этой формуле оно может иметь ненулевую стоимость. Чтобы невилировать это обстоятельство данное выражение необходимо домножить на признак реализованности $i$-го требования:

$$\dot{r}_{\tilde{l}, i} \cdot \sum_{j = 1}^{n}(c_{i, \tilde{n}} \cdot \dot{r}_{\tilde{l}, j})$$

Стоимость одной комплектации - это суммарная стоимость всех реализованных в ней требований:

$$\sum^{n}_{i = 1} \big(\dot{r}_{\tilde{l}, i} \cdot \sum_{j = 1}^{n}(c_{i, j} \cdot \dot{r}_{\tilde{l}, j})\big) = \dot{R}_{\tilde{l}} \cdot C \cdot \dot{R}^{T}_{\tilde{l}}$$

Суммарная стоимость всех реализованных требований во всех комплектациях:

$$\sum(\dot{R}^{T}_{\tilde{l}} \cdot C \cdot \dot{R}_{\tilde{l}})$$

### Алгоритм определения стоимости комплектаций

Алгоритм определения :

1. Определяется состав комплектаций $P_{l \times k}$

2. Рассчитывается объем поставляемого кода в каждой из них:

$$\dot{F}_{m \times l} \gets X \cdot P^{T}$$

3. Выявляется состав реализованных требований в каждой из комплектаций:

$$\dot{R}_{l \times n} \gets f_{im}\big((Q \cdot \dot{F})^{T}\big)$$

4. Рассчитать стоимость комплектаций:

$$\sum(\dot{R}_{\tilde{l}} \cdot C \cdot \dot{R}^{T}_{\tilde{l}})$$

### Задача линейного программирования

Оптимизационная задача может быть решена как задача линейного программирования. С этой целью необходимо построить математическую модель: описать целевую функции и ограничения на значения задействованных переменных.

Для описания ограничений в общем виде используются следующие переменные:

$$\tilde{l} = \overline{1, l} \quad \tilde{n} = \overline{1, n} \quad \tilde{m} = \overline{1, m} \quad \tilde{k} = \overline{1, k}$$

Например, согласно условиям на значения элементов матрицы $X$ действуют следующие ограничения:

$$
\begin{cases}
    x_{1, 1} + x_{1, 2} + \cdots + x_{1, k} = 1 \\
    x_{2, 1} + x_{2, 2} + \cdots + x_{2, k} = 1 \\
    \cdots \\
    x_{m, 1} + x_{m, 2} + \cdots + x_{m, k} = 1
\end{cases}
$$

Используя введенные переменные вышеуказанные ограничения будут записаны так:

$$\sum^{k}_{i = 1} x_{\tilde{m}, i} = 1$$

Формирование целевой функции осуществляется при следовании этапам вышеописанных алгоритмов.

Следуя алгоритму определения состава комплектаций первые три шага не подразумевают наличия переменных, а значит для целевой функции важны значения матрицы $\hat{F}$:

$$\hat{F} \gets R \cdot Q \cdot \sum^{m}_{s = 0} D^{s} =
\begin{pmatrix}
    \hat{f}_{1, 1} & \hat{f}_{1, 2} & \cdots & \hat{f}_{1, m} \\
    \hat{f}_{2, 1} & \hat{f}_{2, 2} & \cdots & \hat{f}_{2, m} \\
    \vdots         & \vdots         & \ddots & \vdots         \\
    \hat{f}_{l, 1} & \hat{f}_{l, 2} & \cdots & \hat{f}_{l, m}
\end{pmatrix}
$$

Далее $\hat{F}$ необходимо умножить на $X$:

$$
P \gets \hat{F} \cdot X = 
\begin{pmatrix}
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{1, i} \cdot x_{i, 1}) & 
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{1, i} \cdot x_{i, 2}) &
    \cdots &
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{1, i} \cdot x_{i, k}) \\

    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{2, i} \cdot x_{i, 1}) & 
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{2, i} \cdot x_{i, 2}) &
    \cdots &
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{2, i} \cdot x_{i, k}) \\

    \vdots   & \vdots   & \ddots & \vdots   \\

    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{l, i} \cdot x_{i, 1}) & 
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{l, i} \cdot x_{i, 2}) &
    \cdots &
    \displaystyle
    \sum^{m}_{i = 1}(\hat{f}_{l, i} \cdot x_{i, k}) \\
\end{pmatrix}
$$

Для рассчета $P$ к каждому элементу матрицы необходимо применить $f_{in}(x)$, для которой так же необходимо выполнить линеаризацию. Для ее линеаризации используется метод big M. Следуя ему, вводится постоянная величина $M$ - условно большое число. Так же модель дополняется бинарной переменной $\alpha \in \{0, 1\}$, на которую действуют следующие ограничения:

$$
f_{in}(x) = 
\begin{cases}
    \alpha < x + 1 \\
    x \le M \cdot \alpha
\end{cases}
$$

Доказательство корректности ограничений методом разбора случаев приведено в таблице:

| $x$   | $\alpha$   | $f_{1}=(\alpha < x + 1)$ | $f_{2} = (x \le M \cdot \alpha)$ | $f_{1} \wedge f_{2}$
|     :-:      |  :-:  | :-:   |  :-:  |  :-:  |
|      0       |   0   | true  | true  | true  |
|      0       |   1   | false | true  | false |
|    (0;1)     |   0   | true  | false | false |
|    (0;1)     |   1   | true  | true  | true  |
|      1       |   0   | true  | false | false |
|      1       |   1   | true  | true  | true  |
| (1;$\infty$) |   0   | false | false | false |
| (1;$\infty$) |   1   | true  | true  | true  |

Для будущей программной реализации строгое неравенство должно быть заменено нестрогим. С этой целью вводится постоянная величина $1 / M$ - условно малое число. Тогда, например, выражение вида $a < b$ будет записано как $a + 1 / M \le b$.

Выражение $f_{in}\big(\displaystyle \sum_{i = 1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}})\big)$ заменяется на $\alpha_{\tilde{l}, \tilde{k}}$, а модель дополняется ограничениями:
$$
\begin{cases}
    \alpha_{\tilde{l}, \tilde{k}} + 1 / M - \displaystyle \sum_{i  =1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}}) \le 0 \\
    \displaystyle \sum_{i = 1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}}) - M \cdot \alpha_{\tilde{l}, \tilde{k}} \le 0
\end{cases}
$$

Эти преобразования дополнили модель $l \cdot k$ переменными и $2 \cdot l \cdot k$ ограничениями.

Состав плагинов каждой из комплектаций:
$$P = 
\begin{pmatrix}
    \alpha_{1, 1} & \alpha_{1, 2} & \cdots & \alpha_{1, k} \\
    \alpha_{2, 1} & \alpha_{2, 2} & \cdots & \alpha_{2, k} \\
    \vdots        & \vdots        & \ddots & \vdots        \\
    \alpha_{l, 1} & \alpha_{l, 2} & \cdots & \alpha_{l, k}
\end{pmatrix}
$$

Cостав поставляемого кода:

$$
\dot{F} \gets X \cdot P^{T} =
\begin{pmatrix}
    \displaystyle
    \sum_{i = 1}^{k}(x_{1, i} \cdot \alpha_{1, i}) &
    \displaystyle
    \sum_{i = 1}^{k}(x_{1, i} \cdot \alpha_{2, i}) &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}(x_{1, i} \cdot \alpha_{l, i}) \\

    \displaystyle
    \sum_{i = 1}^{k}(x_{2, i} \cdot \alpha_{1, i}) &
    \displaystyle
    \sum_{i = 1}^{k}(x_{2, i} \cdot \alpha_{2, i}) &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}(x_{2, i} \cdot \alpha_{l, i}) \\

    \vdots & \vdots & \ddots & \vdots \\

    \displaystyle
    \sum_{i = 1}^{k}(x_{m, i} \cdot \alpha_{1, i}) &
    \displaystyle
    \sum_{i = 1}^{k}(x_{m, i} \cdot \alpha_{2, i}) &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}(x_{m, i} \cdot \alpha_{l, i}) \\

\end{pmatrix}
$$

Выражения в матрице $\dot{F}$ нелинейны. Однако в силу того, что переменные $x$ и $\alpha$ бинарные, каждое из этих выражений может быть приведено к линейному виду благодаря вводу дополнительной бинарной переменной $\beta \in \{0, 1\}$ и дополнению модели следующими ограничениями:

$$
\begin{cases}
    x + \alpha \le \beta + 1 \\
    \beta \le x \\
    \beta \le \alpha
\end{cases}
$$

Доказательство корректности ограничений методом разбора случаев приведенов таблице:

| $x$ | $\alpha$ | $\beta$ | $f_{1}=(x + \alpha \le \beta + 1)$ | $f_{2} = (\beta \le x)$ | $f_{3} = (\beta \le \alpha)$ | $f_{1} \wedge f_{2} \wedge f_{3}$
| :-: | :-: | :-: | :-:   | :-:   |  :-:  |  :-:  |
|  0  |  0  |  0  | true  | true  | true  | true  |
|  0  |  0  |  1  | true  | false | false | false |
|  0  |  1  |  0  | true  | true  | true  | true  |
|  0  |  1  |  1  | true  | false | true  | false |
|  1  |  0  |  0  | true  | true  | true  | true  |
|  1  |  0  |  1  | true  | true  | false | false |
|  1  |  1  |  0  | false | true  | true  | false |
|  1  |  1  |  1  | true  | true  | true  | true  |

Эти преобразования дополняют модель $l \cdot m \cdot k$ переменными и $3 \cdot l \cdot m \cdot k$ ограничениями:

$$
\begin{cases}
    x_{\tilde{m}, \tilde{l}} + \alpha_{\tilde{l}, \tilde{k}} - (\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} + 1) \le 0 \\
    \beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} - x_{\tilde{m}, \tilde{k}} \le 0 \\
    \beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} - \alpha_{\tilde{l}, \tilde{k}} \le 0 \\
\end{cases}
$$

Тогда состав поставляемого кода с учетом введенных переменных:

$$
\dot{F} =
\begin{pmatrix}
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (1 - 1) + i, 1} &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (1 - 1) + i, 2} &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (1 - 1) + i, l} \\

    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (2 - 1) + i, 1} &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (2 - 1) + i, 2} &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (2 - 1) + i, l} \\

    \vdots & \vdots & \ddots & \vdots \\

    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (m - 1) + i, 1} &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (m - 1) + i, 2} &
    \cdots &
    \displaystyle
    \sum_{i = 1}^{k}\beta_{k \cdot (m - 1) + i, l} \\
\end{pmatrix}
$$

Определение состава реализованных требований в комплектациях:

$$\dot{R} \gets f_{im}\big((Q \cdot \dot{F})^{T}\big)$$

$$(Q \cdot \dot{F})^{T} = 
\begin{pmatrix}
    \displaystyle
    \sum_{i = 1}^{m}\big(q_{1, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 1}\big) &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{2, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 1}\big) &

    \cdots &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{n, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 1}\big) \\

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{1, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 2}\big) &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{2, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 2}\big) &

    \cdots &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{n, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, 2}\big) \\

    \vdots & \vdots & \ddots & \vdots \\

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{1, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, l}\big) &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{2, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, l}\big) &

    \cdots &

    \displaystyle
    \sum_{i = 1}^{m}\big(q_{n, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, l}\big) \\

\end{pmatrix}
$$

Для функции $f_{im}$ необходимо выполнить линеаризацию. По аналогии с линеаризацией $f_{in}$ используется метод big M. Модель дополняется бинарной переменной $\gamma \in \{0, 1\}$, на которую действуют следующие ограничения:

$$f_{im}(x) =
\begin{cases}
    x \ge \gamma \\
    x < M \cdot \gamma + 1
\end{cases}
$$

Доказательство корректности ограничений методом разбора случаев приведено в таблице:

| $x$   | $\gamma$   | $f_{1}=(x \ge \gamma)$ | $f_{2} = (x < M \cdot \gamma + 1)$ | $f_{1} \wedge f_{2}$
|     :-:      |  :-:  | :-:   |  :-:  |  :-:  |
|      0       |   0   | true  | true  | true  |
|      0       |   1   | false | true  | false |
|    (0;1)     |   0   | true  | true  | true  |
|    (0;1)     |   1   | false | true  | false |
|      1       |   0   | true  | false | false |
|      1       |   1   | true  | true  | true  |
| (1;$\infty$) |   0   | true  | false | false |
| (1;$\infty$) |   1   | true  | true  | true  |

Эти преобразования дополняют модель $l \cdot n$ переменными и $2 \cdot l \cdot n$ ограничениями:

$$
\begin{cases}
    \displaystyle
    \gamma_{\tilde{l}, \tilde{n}} - \sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big) \le 0 \\
    
    \displaystyle
    \sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big) + 1 / M - (M \cdot \gamma_{\tilde{l}, \tilde{n}} + 1) \le 0
\end{cases}
$$

Тогда состав реализованных требований с учетом введенных переменных:

$$
\dot{R} = 
\begin{pmatrix}
    \gamma_{1, 1} & \gamma_{1, 2} & \cdots & \gamma_{1, n} \\
    \gamma_{2, 1} & \gamma_{2, 2} & \cdots & \gamma_{2, n} \\
    \vdots        & \vdots        & \ddots & \vdots \\
    \gamma_{l, 1} & \gamma_{l, 2} & \cdots & \gamma_{l, n}
\end{pmatrix}
$$

Стоимость реализованного $\tilde{n}$-го требования в $\tilde{l}$-й комплектации:

$$\gamma_{\tilde{l}, \tilde{n}} \cdot \sum_{i = 1}^{n}(c_{\tilde{n}, i} \cdot \gamma_{\tilde{l}, i})$$

Выражение нелинейно. Однако в силу того, что переменные $\gamma$ бинарные, это выражение может быть приведено к линейному виду благодаря вводу дополнительной бинарной переменной $\varphi \in \{0, 1\}$ и дополнению модели следующими ограничениями от умножения бинарных переменных:

$$
\begin{cases}
    \displaystyle
    \gamma_{\tilde{l}, \tilde{n}} + \sum_{i = 1}^{n}(c_{\tilde{n}, i} \cdot \gamma_{\tilde{l}, i}) - (\varphi_{\tilde{l}, \tilde{n}} + 1) \le 0 \\
    \\
    \varphi_{\tilde{l}, \tilde{n}} - \gamma_{\tilde{l}, \tilde{n}} \le 0 \\
    \\
    \displaystyle
    \varphi_{\tilde{l}, \tilde{n}} - \sum_{i = 1}^{n}(c_{\tilde{n}, i} \cdot \gamma_{\tilde{l}, i}) \le 0
\end{cases}
$$

Эти преобразования дополняют модель $l \cdot n$ переменными и $3 \cdot l \cdot n$ ограничениями.

Суммарная стоимость реализованных требований:

Таким образом сформулирована задача линейного программирования:

|     | $min \displaystyle \sum_{i = 1}^{l}\sum_{j = 1}^{n}\varphi_{i, j}$ | 
| :-: |  :-  | 
|s.t.  | $\displaystyle \gamma_{\tilde{l}, \tilde{n}} + \sum_{i = 1}^{n}(c_{\tilde{n}, i} \cdot \gamma_{\tilde{l}, i}) - (\varphi_{\tilde{l}, \tilde{n}} + 1) \le 0$ | 
|     | $\varphi_{\tilde{l}, \tilde{n}} - \gamma_{\tilde{l}, \tilde{n}} \le 0$ | 
|     | $\displaystyle \varphi_{\tilde{l}, \tilde{n}} - \sum_{i = 1}^{n}(c_{\tilde{n}, i} \cdot \gamma_{\tilde{l}, i}) \le 0$ | 
|     | $\displaystyle \gamma_{\tilde{l}, \tilde{n}} - \sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big) \le 0$ | 
|     | $\displaystyle \sum_{i = 1}^{m}\big(q_{\tilde{n}, i} \cdot \sum_{j = 1}^{k}\beta_{k \cdot (i - 1) + j, \tilde{l}}\big) + 1 / M - (M \cdot \gamma_{\tilde{l}, \tilde{n}} + 1) \le 0$ | 
|     |  $x_{\tilde{m}, \tilde{l}} + \alpha_{\tilde{l}, \tilde{k}} - (\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} + 1) \le 0$ | 
|     | $\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} - x_{\tilde{m}, \tilde{k}} \le 0$ | 
|     | $\beta_{k \cdot (\tilde{m} - 1) + \tilde{k}, \tilde{l}} - \alpha_{\tilde{l}, \tilde{k}} \le 0$ | 
|     | $\displaystyle \alpha_{\tilde{l}, \tilde{k}} + 1 / M - \sum_{i = 1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}}) \le 0$ |
|     |  $\displaystyle \sum_{i = 1}^{m}(\hat{f}_{\tilde{l}, i} \cdot x_{i, \tilde{k}}) - M \cdot \alpha_{\tilde{l}, \tilde{k}} \le 0$ |
|     |  $\displaystyle \sum^{k}_{i = 1} x_{\tilde{m}, i} = 1$ |
| | $\tilde{l} = \overline{1, l} \quad \tilde{n} = \overline{1, n} \quad \tilde{m} = \overline{1, m} \quad \tilde{k} = \overline{1, k}$ |
|w.b. | $x, \alpha, \beta, \gamma, \varphi \in \{0, 1\}$ |

Размер модели:

1. Количество переменных: $m \cdot k + l \cdot (k + k \cdot m + 2 \cdot n)$

2. Количество ограничений: $m + l \cdot (3 \cdot m \cdot k + 2 \cdot k + 5 \cdot n)$

### Генетический алгоритм

Альтернативой решения оптимизационной задачи методом ее матиматической формализации является применение эвристических алгоритмов.

При реализации генетического алгоритма нет необходимости проводить линеаризацию модели, однако необходимо определить функции:

1. оценки
2. селекции
3. кроссовера
4. мутации

Ранее была описана функция вычисления суммарной стоимости комплектаций. В качестве оценки может быть использовано противоположное значение:

$$fitness = -1 \cdot \sum^{l}_{\tilde{l} = 1} (\dot{R}_{\tilde{l}} \cdot C \cdot \dot{R}^{T}_{\tilde{l}})$$

Для вычисления этого значения на каждой итерации должно производиться преобразование матрицы $X$ из генерируемого генетическим алгоритмом решения (подобранных значений генов). Рассматривалось $2$ варианта генерируемого решения:

1. $\dot{X}_{1 \times m \cdot k} = ||\dot{x}_{i}||$ - $m \cdot k$ бинарных генов;

2. $\ddot{X}_{1 \times m} = ||\ddot{x}_{i}||$ - $m$ генов со значениями в диапазоне $[1; k]$.

Преобразование $\dot{X}$ в $X$:

$$x_{i, j} = \dot{x}_{i \cdot (k - 1) + j} \quad i = \overline{1, m} \quad j = \overline{1, k}$$

Преобразование $\ddot{X}$ в $X$:

$$X = Z$$

$$j = \ddot{x}_{i} \quad x_{i, j} = 1 \quad i = \overline{1, m}$$

Анализ вариантов генерируемого решения показал, что трансформация $\ddot{X}$ в $X$ гарантирует выполнения условия $\displaystyle \sum_{i = 1}^{m}X_{i} = 1$, кроме того длина вектора $\ddot{X}$ меньше чем длина $\dot{X}$, что упрощает поиск оптимального решения.

Анализ операторов генетического алгоритма не выявил лучший вариант для применения. Поэтому в рамках проводимого исследования были выполнены $3$ реализации генетического алгоритма, включающие следующую конфигурацию:

| оператор | #1 | #2 | #3 |
| :-: | :-: | :-: | :-: |
| кол-во поколений | 1000 | 100 | 100 |
| кол-во хромосом | 100 | 100 | 400 |
| кол-во родительских решений | 4 | 4 | 200 |
| тип родительского выбора | steady-state selection | steady-state selection | steady-state selection |
| число сохраняемых родительских решений | 1 | 1 | 1 |
| тип кроссовера | одноточеный кроссовер | двухточечный кроссовер | одноточеный кроссовер |
| тип мутации | мутация обмена | мутация обмена | мутация обмена |
| % генов для мутации | 10 | 10 | 10 |

## Программная реализация

Программная реализация для решения оптимизационной задачи выполнена на языке программирования Python. Для ее математической формализации и построения задачи линейного программирования использовался модуль Pyomo. Для реализации генетического алгоритма использовался модуль PyGAD. Построение матриц, а так же действия над ними, например, умножние и транспонирование, осуществлялось с применинием модуля Numpy. Подготовка набора данных, сохранение его в виде набора ".csv" файлов и возможность его последующего считывания обеспечивает модуль Pandas.

Для проведения вычислительных экспериментов разработано хранилище:

1. Для каждого эксперимента выделяется директория в файловой системе и отмечается уникальным идентификатором

1. Дирректория включает исходные данные для проведения эксперимента в формате ".csv" и результаты его проведения в формате ".json"

1. Исходными данными являются матрицы $C$, $D$, $R$ и $Q$

1. Результаты проведения эксперимента записываются в файл "solutions.json", структура которого представляет собой массив структур формата, содержащего сведения о:
    
    - название применяемого в эксперименте MILP-решателя или метка конфигурации генетического алгоритма

    - значение функции оценки

    - потребное для выполнения вычислений время

Выполнение программы состоит из следующих основных этапов:

1. Подготовка данных

1. Решение оптимизационной задачи при помощи MILP-решателя или заданной конфигурацией генетического алгоритма

1. Преобразование результатов эксперимента в json структуру

1. Запись результата в файл "solutions.json". Данные будут дописаны в конец файла если для заданного MILP-решателя или метки конфигурации генетического алгоритма экперимент проводится впервые. Если экперимент проводится повторно информация будет обновлена.

Тестирование программы выполнялось для каждого из этапов изолировано друг от друга. Для каждого из них были определены тестировочные входные данные и тестовая реализация вызываемых в рамках работы этапа функций.

Во время разработки возникли проблемы с производительностью при больших значениях коэффициента $m$ для вычисления $\displaystyle \sum_{i = 0}^{m} D^{i}$. Была выполнена оптимизация, которая заключалась в вычислении значений результирующей матрицы заранее на этапе подготовки данных, а не во время выполнения программы. Исходные данные для работы программы дополнены значениями элементов этой матрицы.

На рисунке приведена обощенная схема компонентов разработанной программы.

![alt text](images/UML.png "UML диаграмма")

## Эксперименты и обсуждение

### Цели

Целью проведения экспериментов было сравнение эффективности применения генетических алгоритмов в решени оптимизационной задачи по сравнению с математической формализацией и последующим решением задачи линейного программирования. Ожидаемым результатом является сформулированный критерий при каких условиях и обстоятельствах целесообразнее применять тот или другой подход к решению.

Была выдвинута гипотеза, что при увеличении размеров задачи линейного программирования (число ограничений и переменных) потребное время для работы MILP-решателей растет экспоненциально. Следовательно экспоненциально снижается эффективность их применения при увеличении коэффициентов $n$, $m$, $k$ и $l$. В то время как для генетического алгоритма эффективность снижается при увеличении не всех коэффициетов, а только $m$ и $k$. Значит в задачах большого размера с малыми значениями коэффициентов $m$ и $k$ применение генетического алгоритма должно быть более целесообразно.

### Данные

В экспериментах были задействованы MILP-решатели GNU Linear Programming Kit (glpk), COIN-OR branch and cut (cbc), а так же генетический алгоритм в $3$-х описанных ранее конфигурациях.

Для экспериментов были подготовлены синтезируемые данные. Данные были синтезированы так, чтобы количество переменных в последующем эксперименте отличалось бы от предудыщего на 100. При этом количество ограничений в предыдущем эксперименте не превосходит количество ограничений последующего. Диапазоны значений коэффициентов в экспериментах:

1. $m \in [10; 25]$

1. $k \in [2; m]$

1. $n \in [2; 2 \cdot m]$

1. $l \in [2; 2 \cdot n]$

Данные синтезировались для диапазона количества переменных $[100, 20000]$. На основе подобранных коэффициентов выполнялась генерация матриц $C$, $D$, $R$ и $Q$: 

1. При генерации матрицы $C$ минимальное значение стоимости составляло $0$, максимальное - $1$

1. При генерации матрицы $D$ минимальное число зависимостей составило $0$, максимальное - $2$

1. При генерации матрицы $R$ минимальное число полезных требований в комплектации составило $1$, максимальное - $n$. Дополнительным условием являлась уникальность строк

1. При генерации матрицы $Q$ минимальное число реализующих одно требование файлов составило $1$, максимальное - $2$

Если было невозможно подобрать значения, удовлетворяющие описанным условиям или сгенерировать матрицу $R$ без дублирования строк, то синтез данных переходил к следующей итерации. Всего было подготовлено $194$ набора.

Сведения о фрагменте подготовленных наборов приведены в таблице.

| № эксперимента | m | k | l | n |количество переменных|количество ограничений|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 1 | 14| 2 | 2 | 3 |100|220|
| 2 | 10| 6 | 2 | 2 |200|414|
| 3 | 10| 9 | 2 | 3 |300|616|
| 4 | 14| 8 | 2 | 12|400|838|
| 5 | 11| 10| 3 | 5 |500|1136|
|$\cdots$|$\cdots$|$\cdots$|$\cdots$|$\cdots$|$\cdots$|$\cdots$|
|190| 25| 22| 29| 39|19400|54806|
|191| 23| 20| 34| 40|19500|55103|
|192| 25| 20| 32| 40|19700|55705|
|193| 24| 18| 36| 44|19800|55896|
|194| 25| 16| 39| 42|19900|56263|

### Результаты

#### Потребное время

Результаты проведения эксперементов подтвердили ожидаемый экспоненциальный рост потребного времени MILP-решателям. В то же время рост потребного времени генетическим алгоритмом наблюдается только в конфигурации №3 и может быть объяснен тем, что поздних кспериментах задействованы большие значения $m$ и $k$, а его конфигурация описывает создание большого числа особей в популяции.

На рисунках приведены графики потребного времени от номера эксперимента с дополнительно приведенным полифилом второго порядка.

![alt text](images/glpk.png "glpk")
![alt text](images/cbc.png "cbc")

Скачкообразность графиков объясняется различными значениями сгенерированных матриц, занулением коэффициентов и способностью решателя выполнять оптимизацию рассчетов перед решением оптимизационной задачи. На графиках соответствующих работе генетических алгоритмов интенсивная скачкообразность не наблюдается.

Сравнение построенных полифилов каждого из решений приведено на рисунке.

![alt text](images/all.png "all")

#### Значение функции оценки



### Обсуждение

### Выводы
