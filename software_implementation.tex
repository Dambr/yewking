Описанная модель реализована на языке программирования Java. Реализация сочетает достоинства применения как методологии ООП, так и процедурного программирования. При реализации обособлен выбор типа задействованной коллекции для описания набора вершин и дуг.

% Обозначить, что правильный выбор коллекции - это залог успеха
При проектировании программной реализации было выявлено, что на производительность решения существенное влияние оказывает способ хранения информации о вершинах и дугах. Вариативность способов хранения этой информации зависит от выбранного языка программирования и объема подключаемых библиотек.

% Массивы
Используемый в работах [], [], [] способ хранения информации в массивах является самым простым в реализации. Его использование позволяет наиболее эффективно осуществлять поиск элементов и осуществлять обновление информации о наличествующих в графе вершинах и дугах. Например, как показано в работе [] изменять значение весовых коэффициентов. Данный способ наиболее эффективно использовать при работе на статическом графе, который не изменяется с течением времени. Использование его в динамически изменяющимся графе приведет к необходимости создания новых экземпляров массивов с последующим их заполнением значений.

% Списки
Для проектирования динамически изменяющегося графа необходимо применять динамические структуры данных. Примером таких динамически изменяющихся структур являются связные списки. В работе [4] рассматривается пример их использования. Однако списки допускают хранение одинаковых элементов, что при проектировании описанной графовой модели недопустимо. Модель не предусматривает наличие уникальных идентификаторов. Вследствие этого было принято решение об использовании множеств уникальных значений (Set).

% Структуры
Еще одним важным вопросом при проектировании был способ организации связности данных между собой. Необходимо хранить информацию, какие вершины связаны, какая является начальной, а какая конечной. В работе [2] приводится пример использования многомерных массивов. Однако, как описано ранее, данный подход эффективен при неизменяемом числе связей между компонентами графа. Например, если у каждой вершины зафиксировано число дуг, а в процессе преобразований графа моделью изменяется информация о том, в какие именно дуги соединяют вершину с другими вершинами графа. При проектировании модели, в которой число дуг у вершины графа может изменяться, могут создаваться новые вершины и дуги, удаляться ранее созданные эффективным представляется использование так же динамических структур данных, при проектировании работы так же было принято решение об использовании множеств уникальных значений (Set).

Выбранная структура данных может быть реализована по-разному. Выбор реализации влияет на время работы программной реализации модели. С целью проведения экспериментов и получения информации о зависимости времени работы программы от числа элементов графа в реализации предусмотрены два модуля:
\begin{enumerate}
    \item модуль определения реализации коллекции Set;
    \item модуль генерации исходных данных.
\end{enumerate}

Модуль определения реализации коллекции Set выполнен с целью определения временных характеристик работы программной реализации модели при условии использования различных реализаций этой коллекции. Благодаря использованию этого модуля достигается возможность задания конкретной реализации с последующим ее внедрением в исходный код программной реализации модели. Модуль позволяет внедрять как стандартные реализации коллекции Set, так и реализации, хранящиеся в подключаемых библиотеках или самостоятельно реализованные пользователем.

Модуль генерации исходных данных выполнен с целью сокращения времени на подготовку матрицы трассируемости требований на файлы исходного кода и матрицы зависимостей между файлами исходного кода. В качестве входных данных модуль принимает четыре параметра:
\begin{enumerate}
    \item Fc - число файлов исходного кода;
    \item Rc - число требований к ПО;
    \item Mfc - максимальное число зависимостей у файла исходного кода;
    \item Mfr - максимальное число реализуемых требований в одном файле;
\end{enumerate}