\subsection*{Постановка задачи}
Пусть имеется $n$ требований к ПО, которые трассируются на $m$ файлов исходного кода. Файлы распределены по $k$ плагинам. Требуется определить оптимальное распределение файлов по плагинам для минимальной стоимости сопровождения возможных поставок в заявленных $l$ комплектациях. Стоимость сопровождения требования в рамках поставки зависит от состава поставки и может изменяться от наличия или отсутствия реализованных в поставке других требований.

\subsection*{Комплектации}
В рамках каждой из заявленных комплектаций каждое из возможных требований маркируется либо как \textit{полезное}, либо как \textit{бесполезное}. Поставка должна включать все \textit{полезные} требования. Присвоенные признаки полезности каждому из требований во всех заявленных комплектациях образуют матрицу бинарных отношений $E_{l \times n}$. Элемент $e_{i, j} = 0$ если в рамках $i$-й комплектации $j$-е требование \textit{бесполезно} и $1$ если \textit{полезно}.

\subsection*{Цена постпродажного обслуживания}
Цена постпродажного обслуживания каждого отдельного требования может отличаться в разных поставках. Это происходит из-за того, что по условию задачи наличие или отсутствие других реализованных требований в поставке изменяет цену сопровождения требования и может его как уменьшать так и увеличивать. Образуется матрица изменения стоимости сопровождения требований $P_{n \times n}$. В ней указывается, на сколько изменится цена сопровождения $i$-го требования, если в поставке будет реализовано $j$-е.

\subsection*{Трассируемость требований к ПО на файлы исходного кода}
Каждое требование трассируется на файлы исходного кода. Для реализации требования в поставке в нее должны быть включены все файлы, которые реализуют данное требование. При этом каждое из требований может быть реализовано в одном или нескольких файлах, а каждый файл может реализовывать одно или несколько требований. Так образуется матрица трассируемости $T_{n \times m}$. Каждый из элементов матрицы имеет значение в диапазоне $[0;1]$. Значение определяет условную долю участия файла в реализации требования. Если $j$-й файл не задействован в реализации $i$-го требования, то значение $t_{i, j} = 0$, иначе $0 < t_{i, j} \le 1$. При этом выполняются условия:
\begin{center}
  $\displaystyle \sum^{m}_{j = 1}t_{1, j} = 1, 
    \sum^{m}_{j = 1}t_{2, j} = 1, \cdots, \sum^{m}_{j = 1}t_{n, j} = 1$
\end{center}

\subsection*{Зависимости между файлами исходного кода}
Файлы исходного кода могут иметь зависимости друг на друга. Без разрешения зависимостей файл не может быть включен в поставку. Т.к. число возможных зависимостей у каждого из файлов не может превышать общее число файлов, зависимости между ними описывает матрица бинарных отношений $D_{m \times m}$. В ней элемент $d_{i, j} = 0$ если у $i$-го файла нет зависимости от $j$-го и равен $1$ если зависимость есть. Файл не зависит сам от себя. Поэтому значения элементов на главной диагонале равны $0$.

\subsection*{Распределение файлов исходного кода по плагинам}
Файлы исходного кода распределены по плагинам. Один файл может быть включен только в один плагин, в то время как один плагин может включать в себя множество файлов. Образуется матрица бинарных отношений $A_{m \times k}$. Элемент $a_{i, j} = 0$ если $i$-й файл не включен в $j$-й плагин и равен $1$ если включен. Кроме того на элементы матрицы $A$ действуют ограничения:
\begin{center}
  $\displaystyle \sum^{k}_{j = 1}a_{1, j} = 1, \sum^{k}_{j = 1}a_{2, j}, \cdots, \sum^{k}_{j = 1}a_{m, j} = 1$
\end{center}
Решение задачи поиска оптимальной декомпозиции заключается в нахождении именно этих коэффициентов.

\subsection*{Целевая функция}
Целевая функция может быть записана как минимизация стоимостей поставок во всех возможных комплектациях:
\begin{center}
  $\displaystyle min \sum^{l}_{i = 1} f_{p}(E_{i})$
\end{center}

где $f_{p}$ - функция стоимости сопровождения комплектации. Алгоритм работы этой функции:

\begin{enumerate}
  \item Определить вектор полезных требований $R_{1 \times n}$. Является входным аргументом функции $f_{p}$.
  \item Вычислить вектор полезных файлов исходного кода:
  \begin{center}
    $F_{1 \times m} = R \cdot T$
  \end{center}
  \item Определить минимально необходимый перечень файлов исходного кода для осуществления поставки в заданной комплектации. Для этого разрешить зависимости файлов исходного кода и добавить его к вектору полезных требований: 
  \begin{center}
    $\displaystyle \hat{F}_{1 \times m} = F + \sum^{m}_{j = 1}f_{dep}(j)$
  \end{center}
  Описание функции $f_{dep}$ приведено далее.
  \item Определить плагины, которые должны войти в поставку:
  \begin{center}
    $\dot{P}_{k \times 1} = [f_{in}(\hat{F} \cdot A)]^{T}$
  \end{center}
  \begin{center}
    $
    f_{in} =
    \begin{cases}
      0 & \quad \text{если } x = 0 \\
      1 & \quad \text{если } x > 0
    \end{cases}
    $
  \end{center}
  \item Определить все файлы исходного кода, которые должны войти в поставку:
  \begin{center}
    $\dot{F}_{m \times 1} = A \cdot \dot{P}$
  \end{center}
  \item Определить все реализованные требования в поставке:
  \begin{center}
    $\dot{R}_{n \times 1} = f_{im}(T \cdot \dot{F})$
  \end{center}
  \begin{center}
    $
    f_{im} =
    \begin{cases}
      0 & \quad \text{если } x < 1 \\
      1 & \quad \text{если } x \geq 1
    \end{cases}
    $
  \end{center}
  \item Рассчитать стоимость сопровождения комплектации:
  \begin{center}
    $\dot{R}^{T} \cdot (P \cdot \dot{R})$
  \end{center}
\end{enumerate}

Таким образом целевая функция - это:
  \begin{center}
    $\displaystyle min \sum^{l}_{i = 1} \Bigg[\Bigg[f_{im}\Bigg(T \cdot \bigg(A \cdot \bigg[f_{in}\Big(\big(E_{i} \cdot T + \sum^{m}_{j = 1}f_{dep}(j)\big) \cdot A\Big)\bigg]^{T}\bigg)\Bigg)\Bigg]^{T} \cdot \Bigg[P \cdot~f_{im}\Bigg(T~\cdot~\bigg(A \cdot \bigg[f_{in}\Big(\big(E_{i} \cdot T + \sum^{m}_{j = 1}f_{dep}(j)\big) \cdot A\Big)\bigg]^{T}\bigg)\Bigg)\Bigg]\Bigg]$
  \end{center}

\subsection*{Функция разрешения зависимостей между файлами исходного кода}
Функция разрешения зависимостей между файлами исходного кода $f_{dep}$ позволяет определять перечень зависимостей среди файлов на каждом из слоев зависимостей. Слой зависимости определяет глубину, на которой проводится поиск зависимостей. Так, зависимости полезных файлов имеют уровень $1$. Их зависимости уровень $2$ и т.д. Заметим, что число слоев не может превышать общее число файлов исходного кода $m$.

Например, пусть задача решается для четырех файлов исходного кода. Ниже приведен пример вектора $F$ и матрицы $D$ для этого случая:
\begin{center}
  $
    F = \begin{pmatrix}
      1 & 0 & 0 & 0 
    \end{pmatrix}
  $
\end{center}
\begin{center}
  $
    D = \begin{pmatrix}
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & 1 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 
    \end{pmatrix}
  $
\end{center}
Значения элементов вектора $F$ говорят о том, что полезным является только первое требование. Значения элементов матрицы $D$ говорят, что:
\begin{itemize}
  \item Файл № $1$ имеет зависимость на файл № $2$
  \item Файл № $2$ имеет зависимости на файлы № $3$ и № $4$
  \item Файл № $3$ не имеет зависимостей
  \item Файл № $4$ не имеет зависимостей
\end{itemize}
Тогда зависимости уровня $1$:
\begin{center}
  $
  \begin{pmatrix}
    1 & 0 & 0 & 0 
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & 1 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 
  \end{pmatrix}
  = 
  \begin{pmatrix}
    0 & 1 & 0 & 0 
  \end{pmatrix}
  $
\end{center}
У полезных файлов $F$ присутствует зависимость только на файл № $2$. Это соответствует заданной матрице $D$. Если полученный вектор умножить заново на матрицу $D$, то будут вычислены файлы для разрешения зависимостей их уровня:
\begin{center}
  $
  \begin{pmatrix}
    0 & 1 & 0 & 0 
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
  0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 1 \\
  0 & 0 & 0 & 0 \\
  0 & 0 & 0 & 0 
  \end{pmatrix}
  = 
  \begin{pmatrix}
    0 & 0 & 1 & 1 
  \end{pmatrix}
  $
\end{center}

Исходя из этого $f_{dep}$ можно записать как рекурсивную функцию:
\begin{center}
  $
  f_{dep}(x) = 
  \begin{cases}
    F \cdot D & \quad \text{если } x = 1 \\
    f_{dep}(x - 1) \cdot D & \quad \text{если } x > 1
  \end{cases}
  $
\end{center}
где $x$ - уровень вложенности зависимостей.

Примечателен тот факт, что значение элемента не важно. Если оно больше $0$, значит элемент активен.
