\subsection*{Постановка задачи}
Пусть имеется $n$ требований к ПО, которые трассируются на $m$ файлов исходного кода. Файлы распределены по $k$ плагинам. Требуется определить оптимальное распределение файлов по плагинам для минимальной стоимости сопровождения возможных поставок в заявленных $l$ комплектациях. Стоимость сопровождения требования в рамках поставки зависит от состава поставки и может изменяться от наличия или отсутствия реализованных в поставке других требований.

\subsection*{Комплектации}
В рамках каждой из заявленных комплектаций каждое из возможных требований маркируется либо как \textit{полезное}, либо как \textit{бесполезное}. Поставка должна включать все \textit{полезные} требования. Присвоенные признаки полезности каждому из требований во всех заявленных комплектациях образуют матрицу бинарных отношений $E_{l \times n}$. Элемент $e_{i, j} = 0$ если в рамках $i$-й комплектации $j$-е требование \textit{бесполезно} и $1$ если \textit{полезно}.

\subsection*{Цена постпродажного обслуживания}
Цена постпродажного обслуживания каждого отдельного требования может отличаться в разных поставках. Это происходит из-за того, что по условию задачи наличие или отсутствие других реализованных требований в поставке изменяет цену сопровождения требования и может его как уменьшать так и увеличивать. Образуется матрица изменения стоимости сопровождения требований $P_{n \times n}$. В ней указывается, на сколько изменится цена сопровождения $i$-го требования, если в поставке будет реализовано $j$-е.

\subsection*{Трассируемость требований к ПО на файлы исходного кода}
Каждое требование трассируется на файлы исходного кода. Для реализации требования в поставке в нее должны быть включены все файлы, которые реализуют данное требование. При этом каждое из требований может быть реализовано в одном или нескольких файлах, а каждый файл может реализовывать одно или несколько требований. Так образуется матрица трассируемости $T_{n \times m}$. Каждый из элементов матрицы имеет значение в диапазоне $[0;1]$. Значение определяет условную долю участия файла в реализации требования. Если $j$-й файл не задействован в реализации $i$-го требования, то значение $t_{i, j} = 0$, иначе $0 < t_{i, j} \le 1$. При этом выполняются условия:
\begin{center}
  $\displaystyle \sum^{m}_{j = 1}t_{1, j} = 1, 
    \sum^{m}_{j = 1}t_{2, j} = 1, \cdots, \sum^{m}_{j = 1}t_{n, j} = 1$
\end{center}

\subsection*{Зависимости между файлами исходного кода}
Файлы исходного кода могут иметь зависимости друг на друга. Без разрешения зависимостей файл не может быть включен в поставку. Т.к. число возможных зависимостей у каждого из файлов не может превышать общее число файлов, зависимости между ними описывает матрица бинарных отношений $D_{m \times m}$. В ней элемент $d_{i, j} = 0$ если у $i$-го файла нет зависимости от $j$-го и равен $1$ если зависимость есть. Файл не зависит сам от себя. Поэтому значения элементов на главной диагонале равны $0$.

\subsection*{Распределение файлов исходного кода по плагинам}
Файлы исходного кода распределены по плагинам. Один файл может быть включен только в один плагин, в то время как один плагин может включать в себя множество файлов. Образуется матрица бинарных отношений $A_{m \times k}$. Элемент $a_{i, j} = 0$ если $i$-й файл не включен в $j$-й плагин и равен $1$ если включен. Кроме того на элементы матрицы $A$ действуют ограничения:
\begin{center}
  $\displaystyle \sum^{k}_{j = 1}a_{1, j} = 1, \sum^{k}_{j = 1}a_{2, j}, \cdots, \sum^{k}_{j = 1}a_{m, j} = 1$
\end{center}
Решение задачи поиска оптимальной декомпозиции заключается в нахождении именно этих коэффициентов.

\subsection*{Целевая функция}
Целевая функция может быть записана как минимизация стоимостей поставок во всех возможных комплектациях:
\begin{center}
  $\displaystyle min \sum^{l}_{i = 1} f_{p}(E_{i})$
\end{center}

где $f_{p}$ - функция стоимости сопровождения комплектации. Алгоритм работы этой функции:

\begin{enumerate}
  \item Определить вектор полезных требований $R_{1 \times n}$. Является входным аргументом функции $f_{p}$.
  \item Вычислить вектор полезных файлов исходного кода:
  \begin{center}
    $F_{1 \times m} = R \cdot T$
  \end{center}
  \item Определить минимально необходимый перечень файлов исходного кода для осуществления поставки в заданной комплектации. Для этого разрешить зависимости файлов исходного кода и добавить его к вектору полезных требований: 
  \begin{center}
    $\displaystyle \hat{F}_{1 \times m} = F + \sum^{m}_{j = 1}f_{dep}(j)$
  \end{center}
  Описание функции $f_{dep}$ приведено далее.
  \item Определить плагины, которые должны войти в поставку:
  \begin{center}
    $P_{1 \times k} = f_{in}(\hat{F} \cdot A)$
  \end{center}
  \begin{center}
    $\dot{P}_{k \times 1} = P^{T}$
  \end{center}
  $f_{in}$ - функция, определяющая, входит ли элемент в поставку путем приведения значения к $0$ или $1$. Ее описание приведено далее.
  \item Определить все файлы исходного кода, которые должны войти в поставку:
  \begin{center}
    $\dot{F}_{m \times 1} = f_{bm}(A, \dot{P})$
  \end{center}
  $f_{bm}$ - функция, заменяющая обычное перемножение матриц бинарных отношений для исключения нелинейности в целевой функции. Ее описание приведено далее.
  \item Определить все реализованные требования в поставке:
  \begin{center}
    $\dot{R}_{n \times 1} = f_{im}(T \cdot \dot{F})$
  \end{center}
  $f_{im}$ - функция, определяющая, реализовано ли требование в рамках поставки путем приведения значения к $0$ или $1$. Ее описание приведено далее.
  \item Рассчитать стоимость сопровождения комплектации:
  \begin{center}
    $\sum (P \cdot \dot{R})$
  \end{center}
\end{enumerate}

Таким образом
  \begin{center}
    $f_{p}(i) = \sum(P \cdot f_{im}(T \cdot f_{bm}(A, [f_{in}((E_{i} \cdot T + \sum^{m}_{j = 1}f_{dep}(j)) \cdot A)]^{T})))$
  \end{center}

\subsection*{Функция разрешения зависимостей между файлами исходного кода}
Функция разрешения зависимостей между файлами исходного кода $f_{dep}$ позволяет определять перечень зависимостей среди файлов на каждом из слоев зависимостей. Слой зависимости определяет глубину, на которой проводится поиск зависимостей. Так, зависимости полезных файлов имеют уровень $1$. Их зависимости уровень $2$ и т.д. Заметим, что число слоев не может превышать общее число файлов исходного кода $m$.

Например, пусть задача решается для четырех файлов исходного кода. Ниже приведен пример вектора $F$ и матрицы $D$ для этого случая:
\begin{center}
  $
    F = \begin{pmatrix}
      1 & 0 & 0 & 0 
    \end{pmatrix}
  $
\end{center}
\begin{center}
  $
    D = \begin{pmatrix}
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & 1 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 
    \end{pmatrix}
  $
\end{center}
Значения элементов вектора $F$ говорят о том, что полезным является только первое требование. Значения элементов матрицы $D$ говорят, что:
\begin{itemize}
  \item Файл № $1$ имеет зависимость на файл № $2$
  \item Файл № $2$ имеет зависимости на файлы № $3$ и № $4$
  \item Файл № $3$ не имеет зависимостей
  \item Файл № $4$ не имеет зависимостей
\end{itemize}
Тогда зависимости уровня $1$:
\begin{center}
  $
  \begin{pmatrix}
    1 & 0 & 0 & 0 
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & 1 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 
  \end{pmatrix}
  = 
  \begin{pmatrix}
    0 & 1 & 0 & 0 
  \end{pmatrix}
  $
\end{center}
У полезных файлов $F$ присутствует зависимость только на файл № $2$. Это соответствует заданной матрице $D$. Если полученный вектор умножить заново на матрицу $D$, то будут вычислены файлы для разрешения зависимостей их уровня:
\begin{center}
  $
  \begin{pmatrix}
    0 & 1 & 0 & 0 
  \end{pmatrix}
  \cdot
  \begin{pmatrix}
  0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 1 \\
  0 & 0 & 0 & 0 \\
  0 & 0 & 0 & 0 
  \end{pmatrix}
  = 
  \begin{pmatrix}
    0 & 0 & 1 & 1 
  \end{pmatrix}
  $
\end{center}

Исходя из этого $f_{dep}$ можно записать как рекурсивную функцию:
\begin{center}
  $
  f_{dep}(x) = 
  \begin{cases}
    F \cdot D & \quad \text{если } x = 1 \\
    f_{dep}(x - 1) \cdot D & \quad \text{если } x > 1
  \end{cases}
  $
\end{center}
где $x$ - уровень вложенности зависимостей.

Примечателен тот факт, что значение элемента не важно. Если оно больше $0$, значит элемент активен.

\subsection*{Функция перемножения бинарных матриц}
Функция перемножения бинарных матриц $f_{bm}$ используется как альтернатива обычному перемножению для исключения в моделе нелинейности. Перемножая матрицы обычным способом появляются нелинейные выражения. В рассматриваемой задаче такая нелинейность возникает на этапе вычисления $\dot{F}$. На этом этапе матрица пеменных умножается на матрицу также содержащую переменные, которая образовалась при вычислении $P$. Наличие такой нелинейности в моделе приведет к значительному увеличению параметров в целевой функции и невозможности ее решения большинством программных решателей.

С целью невелирования этого обстоятельства целевая функция в частности и модель в целом должны быть переработаны. Переработка базируется на том обстоятельстве, что перемножаются не матрицы в общем виде, а матрицы именно бинарных отношений. Перемножение матриц заключается в суммировании произведений элементов двух матриц. Каждое произведение элементов $x \cdot y$, где $x$ и $y$ значения бинарных параметров, может быть заменено дополнительной переменной $f$, значение которой должно удовлетворять следующим ограничениям:
\begin{center}
  $
  \begin{cases}
    x + y <= f + 1 & \quad \text{в таблице \ref{tab:fbm} имеет обозначение } f_{1} \\
    f <= x     & \quad \text{в таблице \ref{tab:fbm} имеет обозначение } f_{2} \\
    f <= y     & \quad \text{в таблице \ref{tab:fbm} имеет обозначение } f_{3}
  \end{cases}
  $
\end{center}
Демонстрация робастности ограничений приведена в таблице \ref{tab:fbm}:
\begin{longtable}{|c|c|c|c|c|c|c|}
  \caption{Робастность ограничений $f_{bm}$}
  \label{tab:fbm}\\   
  \hline
  $x$ & $y$ & $f$ & $f_{1}$ & $f_{2}$ & $f_{3}$ & $f_{1} \vee f_{2} \vee f_{3}$ \\
  \endfirsthead
  $x$ & $y$ & $f$ & $f_{1}$ & $f_{2}$ & $f_{3}$ & $f_{1} \vee f_{2} \vee f_{3}$ \\
  \endhead
  \endfoot
  \hline
  0 & 0 & 0 & true  & true  & true  & true \\
  \hline
  0 & 0 & 1 & true  & false & false & false \\
  \hline
  0 & 1 & 0 & true  & true  & true  & true \\
  \hline
  0 & 1 & 1 & true  & false & true  & false \\
  \hline
  1 & 0 & 0 & true  & true  & true  & true \\
  \hline
  1 & 0 & 1 & true  & true  & false & false \\
  \hline
  1 & 1 & 0 & false & true  & true  & false \\
  \hline
  1 & 1 & 1 & true  & true  & true  & true \\
  \hline
\end{longtable}

\subsection*{Функция определения вхождения}
Функция определения вхождения $f_{in}$ применяется с целью преобразования большего или равного $0$ входного параметра в бинарное значение по следующей формуле:
\begin{center}
  $
  f_{in}(x) = \begin{cases}
    0 & \quad \text{если } x = 0 \\
    1 & \quad \text{если } x > 0
  \end{cases}
  $
\end{center}

Данное выражение следует представить в виде переменных и ограничений в модели. Для этого используется метод big M. Этот метод предписывает заведение в модели дополнительной бинарной переменной $f$, значение которой должно удовлетворять следующим ограничениям:
\begin{center}
  $
  \begin{cases}
    f < x + 1 & \quad \text{в таблице \ref{tab:fin} имеет обозначение } f_{1} \\
    x \le M \cdot f & \quad \text{в таблице \ref{tab:fin} имеет обозначение } f_{2}
  \end{cases}
  $
\end{center}

Здесь $M$ - условно большое число. Демонстрация робастности ограничений приведена в таблице \ref{tab:fin}:
\begin{longtable}{|c|c|c|c|c|}
  \caption{Робастность ограничений $f_{in}$}
  \label{tab:fin}\\   
  \hline
  $x$ & $f$ & $f_{1}$ & $f_{2}$ & $f_{1} \vee f_{2}$ \\
  \endfirsthead
  $x$ & $f$ & $f_{1}$ & $f_{2}$ & $f_{1} \vee f_{2}$ \\
  \endhead
  \endfoot
  \hline
  0              & 0 & true  & true  & true \\
  \hline
  0              & 1 & false & true  & false \\
  \hline
  (0 ; 1)        & 0 & true  & false & false \\
  \hline
  (0 ; 1)        & 1 & true  & true  & true \\
  \hline
  1              & 0 & true  & false & false \\
  \hline
  1              & 1 & true  & true  & true \\
  \hline
  (1 ; $\infty$) & 0 & true  & false & false \\
  \hline
  (1 ; $\infty$) & 1 & true  & true  & true \\
  \hline
\end{longtable}

\subsection*{Функция определения реализованности}
Функция определения реализованности $f_{im}$ применяется с целью преобразования большего или равного $0$ входного параметра в бинарное значение по следующей формуле:
\begin{center}
  $
  f_{im}(x) = \begin{cases}
    0 & \quad \text{если } x < 1 \\
    1 & \quad \text{если } x \geq 1
  \end{cases}
  $
\end{center}

Данное выражение следует представить в виде переменных и ограничений в модели. Для этого используется ранее упомянутый метод big M. Следуя ему, ограничения на значение дополнительной бинарной переменной $f$ следующие:
\begin{center}
  $
  \begin{cases}
    x \geq f & \quad \text{в таблице \ref{tab:fim} имеет обозначение } f_{1} \\
    x < M \cdot f + 1 & \quad \text{в таблице \ref{tab:fim} имеет обозначение } f_{2}
  \end{cases}
  $
\end{center}

Демонстрация робастности ограничений приведена в таблице \ref{tab:fim}:
\begin{longtable}{|c|c|c|c|c|}
  \caption{Робастность ограничений $f_{im}$}
  \label{tab:fim}\\   
  \hline
  $x$ & $f$ & $f_{1}$ & $f_{2}$ & $f_{1} \vee f_{2}$ \\
  \endfirsthead
  $x$ & $f$ & $f_{1}$ & $f_{2}$ & $f_{1} \vee f_{2}$ \\
  \endhead
  \endfoot
  \hline
  0              & 0 & true  & true  & true \\
  \hline
  0              & 1 & false & true  & false \\
  \hline
  (0 ; 1)        & 0 & true  & true  & true \\
  \hline
  (0 ; 1)        & 1 & false & true  & false \\
  \hline
  1              & 0 & true  & false & false \\
  \hline
  1              & 1 & true  & true  & true \\
  \hline
  (1 ; $\infty$) & 0 & true  & false & false \\
  \hline
  (1 ; $\infty$) & 1 & true  & true  & true \\
  \hline
\end{longtable}
