% Что пишем в описании модели?

% \begin{enumerate}
%   \item Пишем требования к модели
%   \item Раскрываем каждое требование по отдельности
%   \item Описываем, что каждый элемент функции делает
%   \item Описываем ограничения
%   \item Описываем пример модели с конкретными входными данными
% \end{enumerate}

\subsection*{Постановка задачи}
Пусть имеется $n$ требований к ПО, которые трассируются на $m$ файлов исходного кода. Файлы распределены по $k$ плагинам. Требуется определить оптимальное распределение файлов по плагинам для минимальной стоимости сопровождения возможных поставок в заявленных $l$ комплектациях. Стоимость сопровождения требования в рамках поставки зависит от состава поставки и может изменяться от наличия или отсутствия реализованных в поставке других требований.

\subsection*{Комплектации}
В рамках каждой из заявленных комплектаций каждое из возможных требований маркируется либо как \textit{полезное}, либо как \textit{бесполезное}. Поставка должна включать все \textit{полезные} требования. Присвоенные признаки полезности каждому из требований во всех заявленных комплектациях образуют матрицу бинарных отношений $E_{l \times n}$. Элемент $e_{i, j} = 0$ если в рамках $i$-й комплектации $j$-е требование \textit{бесполезно} и $1$ если \textit{полезно}.

\subsection*{Цена постпродажного обслуживания}
Цена постпродажного обслуживания каждого отдельного требования может отличаться в разных поставках. Это происходит из-за того, что по условию задачи наличие или отсутствие других реализованных требований в поставке изменяет цену сопровождения требования и может его как уменьшать так и увеличивать. Образуется матрица изменения стоимости сопровождения требований $P_{n \times n}$. В ней указывается, на сколько изменится цена сопровождения $i$-го требования, если в поставке будет реализовано $j$-е.

\subsection*{Трассируемость требований к ПО на файлы исходного кода}
Каждое требование трассируется на файлы исходного кода. Для реализации требования в поставке в нее должны быть включены все файлы, которые реализуют данное требование. При этом каждое из требований может быть реализовано в одном или нескольких файлах, а каждый файл может реализовывать одно или несколько требований. Так образуется матрица трассируемости $T_{n \times m}$. Каждый из элементов матрицы имеет значение в диапазоне $[0;1]$. Значение определяет условную долю участия файла в реализации требования. Если $j$-й файл не задействован в реализации $i$-го требования, то значение $t_{i, j} = 0$, иначе $0 < t_{i, j} \le 1$. При этом выполняются условия:
\begin{equation}
  \displaystyle \sum^{m}_{j = 1}t_{1, j} = 1, 
    \sum^{m}_{j = 1}t_{2, j} = 1, \cdots, \sum^{m}_{j = 1}t_{n, j} = 1
\end{equation}

\subsection*{Зависимости между файлами исходного кода}
Файлы исходного кода могут иметь зависимости друг на друга. Без разрешения зависимостей файл не может быть включен в поставку. Т.к. число возможных зависимостей у каждого из файлов не может превышать общее число файлов, зависимости между ними описывает матрица бинарных отношений $D_{m \times m}$. В ней элемент $d_{i, j} = 0$ если у $i$-го файла нет зависимости от $j$-го и равен $1$ если зависимость есть. Файл не зависит сам от себя. Поэтому значения элементов на главной диагонале равны $0$.

\subsection*{Распределение файлов исходного кода по плагинам}
Файлы исходного кода распределены по плагинам. Один файл может быть включен только в один плагин, в то время как один плагин может включать в себя множество файлов. Образуется матрица бинарных отношений $A_{m \times k}$. Элемент $a_{i, j} = 0$ если $i$-й файл не включен в $j$-й плагин и равен $1$ если включен. Кроме того на элементы матрицы $A$ действуют ограничения:
\begin{equation}
  \displaystyle \sum^{k}_{j = 1}a_{1, j} = 1, \sum^{k}_{j = 1}a_{2, j}, \cdots, \sum^{k}_{j = 1}a_{m, j} = 1
\end{equation}
Решение задачи поиска оптимальной декомпозиции заключается в нахождении именно этих коэффициентов.

\subsection*{Целевая функция}
Целевая функция может быть записана как минимизация стоимостей поставок во всех возможных комплектациях:
\begin{equation}
    \displaystyle min \sum^{l}_{i = 1} f_{p}(E_{i})
\end{equation}

где $f_{p}$ - функция стоимости комплектации. Алгоритм работы этой функции:

\begin{enumerate}
  \item Определить вектор полезных требований $R_{1 \times n}$. Является входным аргументом функции $f_{p}$.
  \item Вычислить вектор полезных файлов исходного кода:
  \begin{equation}
    F_{1 \times m} = R \cdot T
  \end{equation}
  \item Определить минимально необходимый перечень файлов исходного кода для осуществления поставки в заданной комплектации. Для этого разрешить зависимости файлов исходного кода и добавить его к вектору полезных требований: 
  \begin{equation}
    \displaystyle \hat{F}_{1 \times m} = F + \sum^{m}_{i = 1}d_{f}(i)
  \end{equation}
  Описание функции $d_{f}$ приведено далее.
  \item Определить плагины, которые должны войти в поставку:
  \begin{equation}
    P_{1 \times k} = c_{in}(\hat{F} \cdot A)
  \end{equation}
  \begin{equation}
    \dot{P} = P^{T}
  \end{equation}
  $c_{in}$ - функция, определяющая, входит ли элемент в поставку путем приведения ее значения к $0$ или $1$. Ее описание приведено далее.
  \item Определить все файлы исходного кода, которые должны войти в поставку:
  \begin{equation}
    \dot{F}_{m \times 1} = m_{b}(A, \dot{P})
  \end{equation}
  $m_{b}$ - функция, заменяющая обычное перемножение матриц бинарных отношений для исключения нелинейности в целевой функции. Ее описание приведено далее.
  \item Определить все реализованные требования в поставке:
  \begin{equation}
    \dot{R}_{n \times 1} = c_{im}(T \cdot \dot{F})
  \end{equation}

\end{enumerate}


